[{"title":"spring","path":"/2023/04/25/spring/","content":"Spring66.0.2 Spring 有两个核心模块：IOC和AOP 主要围绕core部分进行讲解。 B站上看到的面试题1、单例bean 单例bean的底层实现是map 2、Spring如何解决循环依赖的？ 倒数第二步那里应该是从二级缓存中删除A，不是三级缓存。前面已经把从三级缓存删除了 spring AOP动态代理的原理1、核心业务和非核心业务（横切关注点），AOP的作用aop是ioc的扩展功能。核心业务是竖向的，自上而下的，比如从http到controller到service到dao，而非核心业务，比如日志，非核心业务的执行不需要自上而下，和主业务逻辑没有直接关系。 ①横切关注点（非核心业务）分散在每个各个模块中解决同一样的问题，如用户验证、日志管理、事务处理、数据缓存都属于横切关注点。 从每个方法中抽取出来的同一类非核心业务。在同一个项目中，我们可以使用多个横切关注点对相关方法进行多个不同方面的增强。 这个概念不是语法层面的，而是根据附加功能的逻辑上的需要：有十个附加功能，就有十个横切关注点。 ②通知（增强）增强，通俗说，就是你想要增强的功能，比如 安全，事务，日志等。 每一个横切关注点上要做的事情都需要写一个方法来实现，这样的方法就叫通知方法。 前置通知：在被代理的目标方法前执行 返回通知：在被代理的目标方法成功结束后执行（寿终正寝） 异常通知：在被代理的目标方法异常结束后执行（死于非命） 后置通知：在被代理的目标方法最终结束后执行（盖棺定论） 环绕通知：使用try…catch…finally结构围绕整个被代理的目标方法，包括上面四种通知对应的所有位置 ③切面封装通知方法的类。 ④目标被代理的目标对象。 ⑤代理向目标对象应用通知之后创建的代理对象。 ⑥连接点这也是一个纯逻辑概念，不是语法定义的。 把方法排成一排，每一个横切位置看成x轴方向，把方法从上到下执行的顺序看成y轴，x轴和y轴的交叉点就是连接点。通俗说，就是spring允许你使用通知的地方 ⑦切入点定位连接点的方式。 每个类的方法中都包含多个连接点，所以连接点是类中客观存在的事物（从逻辑上来说）。 如果把连接点看作数据库中的记录，那么切入点就是查询记录的 SQL 语句。 Spring 的 AOP 技术可以通过切入点定位到特定的连接点。通俗说，要实际去增强的方法。 切点通过 org.springframework.aop.Pointcut 接口进行描述，它使用类和方法作为连接点的查询条件。 切入点表达式: “execution(权限修饰符 方法返回值 方法全类名 方法名(参数列表))” 2、动态代理分两类 ​ 指向jdk 指向CGLib 如果有接口，使用jdk动态代理，生成得到接口实现类的代理对象。 如果没有接口，使用cglib动态代理，生成子类代理对象 动态代理分为JDK动态代理和cglib动态代理 当目标类有接口的情况使用JDK动态代理和cglib动态代理，没有接口时只能使用cglib动态代理 JDK动态代理动态生成的代理类会在com.sun.proxy包下，类名为$proxy1，和目标类实现相同的接口 cglib动态代理动态生成的代理类会和目标在在相同的包下，会继承目标类 动态代理（InvocationHandler）：JDK原生的实现方式，需要被代理的目标类必须实现接口。因为这个技术要求代理对象和目标对象实现同样的接口（兄弟两个拜把子模式）。 cglib：通过继承被代理的目标类（认干爹模式）实现代理，所以不需要目标类实现接口。 AspectJ：是AOP思想的一种实现。本质上是静态代理，将代理逻辑“织入”被代理的目标类编译得到的字节码文件，所以最终效果是动态的。weaver就是织入器。Spring只是借用了AspectJ中的注解。 3、jdk代理底层实现jdk里面有个类叫Proxy，通过这个类来实现，这个类里面有个方法叫 来获取代理对象。这个方法有3个参数，第一个是类加载器，加载动态生成代理类的类加载器 第二个 目标对象实现的所有接口的class类型数组 第三个 InvocationHandler 设置代理对象实现目标对象方法的过程 spring bean对象生存周期1.加载Bean定义通过 loadBeanDefinitions 扫描所有xml配置、注解将Bean记录在beanDefinitionMap中 2.创建Bean对象通过 createBean 遍历 beanDefinitionMap 创建bean 2.1.构建对象 容器通过 createBeanInstance 进行对象构造 获取构造方法：@Autowired 准备参数 根据类查找&gt;参数名查找 构造对象 无参对象直接实例化 2.2.填充属性通过populateBean方法为Bean内部所需的属性进行赋值 通常是 @Autowired 注解的变量 依赖注入（三级缓存） 2.3.初始化Bean对象通过initializeBean对填充后的实例进行初始化 填充初始化容器相关信息通过 invokeAwareMethods 方法：为实现aware接口【信息感知接口】的Bean 设置注入beanName、beanFactory等容器信息 初始化构造方法通过 invokeInitMethods 方法进行初始化： 如果Bean实现InitializingBean接口进行处理【未实现则不进行】 afterPropertiesSet方法【bean填充属性后执行】 initMethod 方法 Bean的后置处理在invokeInitMethods 的前后进行（也就是Bean对象初始化前后） applyBeanPostProcessorsBeforeInitialization invokeInitMethods applyBeanPostProcessorsAfterInitialization ⭐在后置处理中处理了包括：（这后置处理器可以引入AOP）AOP【AnnotationAwareAspectJAutoProxyCreator】 负责 构造后@PostConstruct 和 销毁前@PreDestroy 的 InitDestoryAnnotationBeanPostProcessor 等 注册销毁通过reigsterDisposableBean处理实现了DisposableBean接口的Bean的注册 3.添加到单例池通过 addSingleton 方法，将Bean 加入到单例池 singleObjects 4.销毁4.1.销毁前调用 bean中@PreDestory 注解的方法 通过 postProcessBeforeDestruction 方法调用destoryBean逐一销毁Bean 4.2.销毁调用 destoryBeans 4.3.执行客户自定义销毁调用 invokeCustomDestoryMethod spring核心ioc整理1、spring ioc是什么IOC是什么？IOC的中文翻译是控制翻转，就是将对象的管理权限交给容器。 2、容器容器是什么，容器存储bean对象，使用Map结构存储，在spring中存在三级缓存。bean的生命周期由容器来管理。 容器的创建过程 beanFactory ，向bean工厂中设置一些参数。 ⭐3、三级缓存（3个map） 一级缓存 单例池 singletonObjects ConcurrentHashMap 作用：保存单例bean对象 二级缓存 earlySingletonObjects ConcurrentHashMap 作用：防止代理对象重复创建；自己还没有走过完整创建周期时，在途中要保存提前需要给其他bean去用的（代理）对象；这个是最难理解的， 举个例子，AB循环依赖，B中还有C，C中有A，A中无C 创建A的时候，A中的B中的A做完AOP，此时A的代理对象在2级缓存中保存，然后B中的C也需要注入A，此时C再去注入A的时候，就不用重新创建A的代理对象，而是在2级缓存中去取A即可。 三级缓存 singletonFactories HashMap 实际存的lambda表达式 打破循环依赖 循环依赖过程： 创建A普通对象，扔到三级缓存中，去创建B的普通对象，实例化扔B到三级缓存池，（在添加到三级缓存的过程中）判断B是不是循环依赖，这里B不是，正常走，然后到B中A对象这里，先在单例池找，然后在二级缓存池找，找不到，然后在三级缓存池找，找到了，判断A是循环依赖，可能会执行AOP（如果有循环依赖，需要提前执行AOP，得到动态代理对象），也可能不会，AOP走完后，A的代理对象会保存在2级缓存中，然后这里B的创建可以正常执行，然后B进入一级缓存，删除三级缓存中的B，然后A扔到一级缓存，三级缓存中的A删除。 https://www.bilibili.com/video/BV1dP411J7tQ?p=6&amp;spm_id_from=pageDriver&amp;vd_source=5470cc37d9656eccfe1eb4e48a6704e5 p5倒数3分钟 4、Bean的声明方式xml和注解，spring启动时会解析这些bean并保存在ioc容器里面，包括bean的创建、依赖注入和初始化。bean对象放单例池，用Map存储。生存周期见上。（什么是单例池，存单例bean对象的池子） BeanPostProcessor?这个是后置处理器 5、反射原理通过反射的方式讲BeanDefinition对象实例化成具体的bean对象 环境 入门案例使用spring来创建对象 第一步 引入spring相关依赖 第二步 创建类，定义属性和方法 第三步 安装spring要求创建配置文件 第四步 在spring配置文件配置相关信息 第五步 进行最终测试 过程解析 底层是用反射实现的。 key:唯一标识 value类的定义（描述信息） 启用日志框架 引入Log4j2依赖 12345678910&lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;version&gt;2.19.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-slf4j2-impl&lt;/artifactId&gt; &lt;version&gt;2.19.0&lt;/version&gt; &lt;/dependency&gt; 新建日志配置文件resourse-&gt;log4j2.xml 配置完成后就可以了 手动写日志private Logger logger = LoggerFactory.getLogger(公共类名.class); Spring 核心IOC（容器）IoC 是 Inversion of Control 的简写，译为“控制反转” Spring 通过 IoC 容器来管理所有 Java 对象的实例化和初始化，控制对象与对象之间的依赖关系。我们将由 IoC 容器管理的 Java 对象称为 Spring Bean，它与使用关键字 new 创建的 Java 对象没有任何区别。 获取bean的三种方法①方式一：根据id获取由于 id 属性指定了 bean 的唯一标识，所以根据 bean 标签的 id 属性可以精确获取到一个组件对象。上个实验中我们使用的就是这种方式。 ②方式二：根据类型获取123456@Testpublic void testHelloWorld1()&#123;\tApplicationContext ac = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); HelloWorld bean = ac.getBean(HelloWorld.class);//当根据类型获取bean时，要求IOC容器中指定类型的bean有且只能有一个，当IOC容器中一共配置了两个，会抛出异常 bean.sayHello();&#125; ③方式三：根据id和类型123456@Testpublic void testHelloWorld2()&#123;\tApplicationContext ac = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); HelloWorld bean = ac.getBean(&quot;helloworld&quot;, HelloWorld.class); bean.sayHello();&#125; ④注意的地方当根据类型获取bean时，要求IOC容器中指定类型的bean有且只能有一个 当IOC容器中一共配置了两个： 12&lt;bean id=&quot;helloworldOne&quot; class=&quot;com.atguigu.spring6.bean.HelloWorld&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;helloworldTwo&quot; class=&quot;com.atguigu.spring6.bean.HelloWorld&quot;&gt;&lt;/bean&gt; 根据类型获取时会抛出异常： org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type ‘com.atguigu.spring6.bean.HelloWorld’ available: expected single matching bean but found 2: helloworldOne,helloworldTwo ⑤扩展知识如果组件类实现了接口，根据接口类型可以获取 bean 吗？ 可以，前提是bean唯一（实现该接口的实现类唯一，也就是只有一个类实现了该接口） 如果一个接口有多个实现类，这些实现类都配置了 bean，根据接口类型可以获取 bean 吗？ 不行，因为bean不唯一 结论 根据类型来获取bean时，在满足bean唯一性的前提下，其实只是看：『对象 instanceof 指定的类型』的返回结果，只要返回的是true就可以认定为和类型匹配，能够获取到。 java中，instanceof运算符用于判断前面的对象是否是后面的类，或其子类、实现类的实例。如果是返回true，否则返回false。也就是说：用instanceof关键字做判断时， instanceof 操作符的左右操作必须有继承或实现关系 xml依赖注入实际上就是给成员属性赋值，一般有两个方法，一个是通过有参数构造器进行赋值，一个是根据set方法进行赋值。 一 使用set完成依赖注入首先在对应的类中实现set代码，如： 123public void setId(Integer id) &#123; this.id = id; &#125; 然后配置bean时为属性赋值 （这里是property，而构造器是constructor-arg） 123456789&lt;bean id=&quot;studentOne&quot; class=&quot;com.atguigu.spring6.bean.Student&quot;&gt; &lt;!-- property标签：通过组件类的setXxx()方法给组件对象设置属性 --&gt; &lt;!-- name属性：指定属性名（这个属性名是getXxx()、setXxx()方法定义的，和成员变量无关） --&gt; &lt;!-- value属性：指定属性值 --&gt; &lt;property name=&quot;id&quot; value=&quot;1001&quot;&gt;&lt;/property&gt; &lt;property name=&quot;name&quot; value=&quot;张三&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;23&quot;&gt;&lt;/property&gt; &lt;property name=&quot;sex&quot; value=&quot;男&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 测试 123456@Testpublic void testDIBySet()&#123; ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;spring-di.xml&quot;); Student studentOne = ac.getBean(&quot;studentOne&quot;, Student.class); System.out.println(studentOne);&#125; 二 使用构造器完成依赖注入①在Student类中添加有参构造 123456public Student(Integer id, String name, Integer age, String sex) &#123; this.id = id; this.name = name; this.age = age; this.sex = sex;&#125; ②配置bean spring-di.xml 123456&lt;bean id=&quot;studentTwo&quot; class=&quot;com.atguigu.spring6.bean.Student&quot;&gt; &lt;constructor-arg value=&quot;1002&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;李四&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;33&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;女&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 注意： constructor-arg标签还有两个属性可以进一步描述构造器参数： index属性：指定参数所在位置的索引（从0开始） name属性：指定参数名 ③测试 123456@Testpublic void testDIByConstructor()&#123; ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;spring-di.xml&quot;); Student studentOne = ac.getBean(&quot;studentTwo&quot;, Student.class); System.out.println(studentOne);&#125; 特殊值处理null值123&lt;property name=&quot;name&quot;&gt; &lt;null /&gt;&lt;/property&gt; 注意： 1&lt;property name=&quot;name&quot; value=&quot;null&quot;&gt;&lt;/property&gt; 以上写法，为name所赋的值是字符串null xml实体&lt;&gt;这种符号必须要进行转义 &lt; \\&lt; > \\&gt; 1234&lt;!-- 小于号在XML文档中用来定义标签的开始，不能随便使用 --&gt;&lt;!-- 解决方案一：使用XML实体来代替 --&gt;&lt;property name=&quot;expression&quot; value=&quot;a &amp;lt; b&quot;/&gt;&lt;!-- a &lt; b --&gt; 或者使用CDATA节1234567&lt;property name=&quot;expression&quot;&gt; &lt;!-- 解决方案二：使用CDATA节 --&gt; &lt;!-- CDATA中的C代表Character，是文本、字符的含义，CDATA就表示纯文本数据 --&gt; &lt;!-- XML解析器看到CDATA节就知道这里是纯文本，就不会当作XML标签或属性来解析 --&gt; &lt;!-- 所以CDATA节中写什么符号都随意 --&gt; &lt;value&gt;&lt;![CDATA[a &lt; b]]&gt;&lt;/value&gt;&lt;/property&gt; ![CDATA[ ]] 3种对象类型注入方式（set注入）一对多的关系：一个部门有多个员工 方式一：引用外部bean在一个bean中使用ref引用已有的另一个bean 1、配置Clazz类型的bean： 1234&lt;bean id=&quot;clazzOne&quot; class=&quot;com.atguigu.spring6.bean.Clazz&quot;&gt; &lt;property name=&quot;clazzId&quot; value=&quot;1111&quot;&gt;&lt;/property&gt; &lt;property name=&quot;clazzName&quot; value=&quot;财源滚滚班&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 2、为Student中的clazz属性赋值： 12345678&lt;bean id=&quot;studentFour&quot; class=&quot;com.atguigu.spring6.bean.Student&quot;&gt; &lt;property name=&quot;id&quot; value=&quot;1004&quot;&gt;&lt;/property&gt; &lt;property name=&quot;name&quot; value=&quot;赵六&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;26&quot;&gt;&lt;/property&gt; &lt;property name=&quot;sex&quot; value=&quot;女&quot;&gt;&lt;/property&gt; &lt;!-- ref属性：引用IOC容器中某个bean的id，将所对应的bean为属性赋值 --&gt; &lt;property name=&quot;clazz&quot; ref=&quot;clazzOne&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 核心： 12&lt;property name=&quot;clazz&quot; ref=&quot;clazzOne&quot;&gt;&lt;/property&gt;&quot;clazzOne&quot;是另外一个类的id值 错误演示： 1234567&lt;bean id=&quot;studentFour&quot; class=&quot;com.atguigu.spring6.bean.Student&quot;&gt; &lt;property name=&quot;id&quot; value=&quot;1004&quot;&gt;&lt;/property&gt; &lt;property name=&quot;name&quot; value=&quot;赵六&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;26&quot;&gt;&lt;/property&gt; &lt;property name=&quot;sex&quot; value=&quot;女&quot;&gt;&lt;/property&gt; &lt;property name=&quot;clazz&quot; value=&quot;clazzOne&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 如果错把ref属性写成了value属性，会抛出异常： Caused by: java.lang.IllegalStateException: Cannot convert value of type ‘java.lang.String’ to required type ‘com.atguigu.spring6.bean.Clazz’ for property ‘clazz’: no matching editors or conversion strategy found 意思是不能把String类型转换成我们要的Clazz类型，说明我们使用value属性时，Spring只把这个属性看做一个普通的字符串，不会认为这是一个bean的id，更不会根据它去找到bean来赋值 方式二：内部bean1234567891011121314&lt;bean id=&quot;studentFour&quot; class=&quot;com.atguigu.spring6.bean.Student&quot;&gt; &lt;property name=&quot;id&quot; value=&quot;1004&quot;&gt;&lt;/property&gt; &lt;property name=&quot;name&quot; value=&quot;赵六&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;26&quot;&gt;&lt;/property&gt; &lt;property name=&quot;sex&quot; value=&quot;女&quot;&gt;&lt;/property&gt; &lt;property name=&quot;clazz&quot;&gt; &lt;!-- 在一个bean中再声明一个bean就是内部bean --&gt; &lt;!-- 内部bean只能用于给属性赋值，不能在外部通过IOC容器获取，因此可以省略id属性 --&gt; &lt;bean id=&quot;clazzInner&quot; class=&quot;com.atguigu.spring6.bean.Clazz&quot;&gt; &lt;property name=&quot;clazzId&quot; value=&quot;2222&quot;&gt;&lt;/property&gt; &lt;property name=&quot;clazzName&quot; value=&quot;远大前程班&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/property&gt;&lt;/bean&gt; 方式三：级联属性赋值先引用其他bean，然后修改其中的值 123456789&lt;bean id=&quot;studentFour&quot; class=&quot;com.atguigu.spring6.bean.Student&quot;&gt; &lt;property name=&quot;id&quot; value=&quot;1004&quot;&gt;&lt;/property&gt; &lt;property name=&quot;name&quot; value=&quot;赵六&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;26&quot;&gt;&lt;/property&gt; &lt;property name=&quot;sex&quot; value=&quot;女&quot;&gt;&lt;/property&gt; &lt;property name=&quot;clazz&quot; ref=&quot;clazzOne&quot;&gt;&lt;/property&gt; &lt;property name=&quot;clazz.clazzId&quot; value=&quot;3333&quot;&gt;&lt;/property&gt; &lt;property name=&quot;clazz.clazzName&quot; value=&quot;最强王者班&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 数组类型注入（一个一个赋值）123456789101112131415&lt;bean id=&quot;studentFour&quot; class=&quot;com.atguigu.spring.bean6.Student&quot;&gt; &lt;property name=&quot;id&quot; value=&quot;1004&quot;&gt;&lt;/property&gt; &lt;property name=&quot;name&quot; value=&quot;赵六&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;26&quot;&gt;&lt;/property&gt; &lt;property name=&quot;sex&quot; value=&quot;女&quot;&gt;&lt;/property&gt; &lt;!-- ref属性：引用IOC容器中某个bean的id，将所对应的bean为属性赋值 --&gt; &lt;property name=&quot;clazz&quot; ref=&quot;clazzOne&quot;&gt;&lt;/property&gt; &lt;property name=&quot;hobbies&quot;&gt; &lt;array&gt; &lt;value&gt;抽烟&lt;/value&gt; &lt;value&gt;喝酒&lt;/value&gt; &lt;value&gt;烫头&lt;/value&gt; &lt;/array&gt; &lt;/property&gt;&lt;/bean&gt; 数组的名字是hobbies hobbies标签下跟多个value进行数组的注入 核心 1234567&lt;property name=&quot;hobbies&quot;&gt; &lt;array&gt; &lt;value&gt;抽烟&lt;/value&gt; &lt;value&gt;喝酒&lt;/value&gt; &lt;value&gt;烫头&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; 集合注入（一个一个赋值）①为List集合类型属性赋值在Clazz类中添加以下代码： 123456789private List&lt;Student&gt; students;public List&lt;Student&gt; getStudents() &#123; return students;&#125;public void setStudents(List&lt;Student&gt; students) &#123; this.students = students;&#125; 配置bean： 1234567891011&lt;bean id=&quot;clazzTwo&quot; class=&quot;com.atguigu.spring6.bean.Clazz&quot;&gt; &lt;property name=&quot;clazzId&quot; value=&quot;4444&quot;&gt;&lt;/property&gt; &lt;property name=&quot;clazzName&quot; value=&quot;Javaee0222&quot;&gt;&lt;/property&gt; &lt;property name=&quot;students&quot;&gt; &lt;list&gt; &lt;ref bean=&quot;studentOne&quot;&gt;&lt;/ref&gt; &lt;ref bean=&quot;studentTwo&quot;&gt;&lt;/ref&gt; &lt;ref bean=&quot;studentThree&quot;&gt;&lt;/ref&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; 若为Set集合类型属性赋值，只需要将其中的list标签改为set标签即可 核心：list的名字是students；注意这里用ref的原因是集合的元素是对象 1234567&lt;property name=&quot;students&quot;&gt; &lt;list&gt; &lt;ref bean=&quot;studentOne&quot;&gt;&lt;/ref&gt; &lt;ref bean=&quot;studentTwo&quot;&gt;&lt;/ref&gt; &lt;ref bean=&quot;studentThree&quot;&gt;&lt;/ref&gt; &lt;/list&gt;&lt;/property&gt; ②为Map集合类型属性赋值创建教师类Teacher： 12345678910111213141516171819202122232425262728293031323334353637383940package com.atguigu.spring6.bean;public class Teacher &#123; private Integer teacherId; private String teacherName; public Integer getTeacherId() &#123; return teacherId; &#125; public void setTeacherId(Integer teacherId) &#123; this.teacherId = teacherId; &#125; public String getTeacherName() &#123; return teacherName; &#125; public void setTeacherName(String teacherName) &#123; this.teacherName = teacherName; &#125; public Teacher(Integer teacherId, String teacherName) &#123; this.teacherId = teacherId; this.teacherName = teacherName; &#125; public Teacher() &#123; &#125; @Override public String toString() &#123; return &quot;Teacher&#123;&quot; + &quot;teacherId=&quot; + teacherId + &quot;, teacherName=&#x27;&quot; + teacherName + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 在Student类中添加以下代码： 123456789private Map&lt;String, Teacher&gt; teacherMap;public Map&lt;String, Teacher&gt; getTeacherMap() &#123; return teacherMap;&#125;public void setTeacherMap(Map&lt;String, Teacher&gt; teacherMap) &#123; this.teacherMap = teacherMap;&#125; 配置bean： map的名称teacherMap 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;bean id=&quot;teacherOne&quot; class=&quot;com.atguigu.spring6.bean.Teacher&quot;&gt; &lt;property name=&quot;teacherId&quot; value=&quot;10010&quot;&gt;&lt;/property&gt; &lt;property name=&quot;teacherName&quot; value=&quot;大宝&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=&quot;teacherTwo&quot; class=&quot;com.atguigu.spring6.bean.Teacher&quot;&gt; &lt;property name=&quot;teacherId&quot; value=&quot;10086&quot;&gt;&lt;/property&gt; &lt;property name=&quot;teacherName&quot; value=&quot;二宝&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=&quot;studentFour&quot; class=&quot;com.atguigu.spring6.bean.Student&quot;&gt; &lt;property name=&quot;id&quot; value=&quot;1004&quot;&gt;&lt;/property&gt; &lt;property name=&quot;name&quot; value=&quot;赵六&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;26&quot;&gt;&lt;/property&gt; &lt;property name=&quot;sex&quot; value=&quot;女&quot;&gt;&lt;/property&gt; &lt;!-- ref属性：引用IOC容器中某个bean的id，将所对应的bean为属性赋值 --&gt; &lt;property name=&quot;clazz&quot; ref=&quot;clazzOne&quot;&gt;&lt;/property&gt; &lt;property name=&quot;hobbies&quot;&gt; &lt;array&gt; &lt;value&gt;抽烟&lt;/value&gt; &lt;value&gt;喝酒&lt;/value&gt; &lt;value&gt;烫头&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;property name=&quot;teacherMap&quot;&gt; &lt;map&gt; &lt;entry&gt; &lt;key&gt; &lt;value&gt;10010&lt;/value&gt; &lt;/key&gt; &lt;ref bean=&quot;teacherOne&quot;&gt;&lt;/ref&gt; &lt;!--如果是基础数据类型：&lt;value&gt;100&lt;/value&gt;--&gt; &lt;/entry&gt; &lt;entry&gt; &lt;key&gt; &lt;value&gt;10086&lt;/value&gt; &lt;/key&gt; &lt;ref bean=&quot;teacherTwo&quot;&gt;&lt;/ref&gt; &lt;/entry&gt; &lt;/map&gt; &lt;/property&gt;&lt;/bean&gt; 核心代码： 123456789101112131415&lt;map&gt; &lt;entry&gt; &lt;key&gt; &lt;value&gt;10010&lt;/value&gt; &lt;/key&gt; &lt;ref bean=&quot;teacherOne&quot;&gt;&lt;/ref&gt; &lt;!--如果是基础数据类型：&lt;value&gt;100&lt;/value&gt;--&gt; &lt;/entry&gt; &lt;entry&gt; &lt;key&gt; &lt;value&gt;10086&lt;/value&gt; &lt;/key&gt; &lt;ref bean=&quot;teacherTwo&quot;&gt;&lt;/ref&gt; &lt;/entry&gt; &lt;/map&gt; ③直接使用集合类型的bean以list为例，首先创建list中的各个对象，然后用util:list将各个对象框（引用）起来，然后某个类进行成员赋值的时候有属性是对象列表，就引用util:list来赋值。 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!--定义list集合类型的bean--&gt;&lt;util:list id=&quot;students&quot;&gt; &lt;ref bean=&quot;studentOne&quot;&gt;&lt;/ref&gt; &lt;ref bean=&quot;studentTwo&quot;&gt;&lt;/ref&gt; &lt;ref bean=&quot;studentThree&quot;&gt;&lt;/ref&gt;&lt;/util:list&gt;&lt;!--定义map集合类型的bean--&gt;&lt;util:map id=&quot;teacherMap&quot;&gt; &lt;entry&gt; &lt;key&gt; &lt;value&gt;10010&lt;/value&gt; &lt;/key&gt; &lt;ref bean=&quot;teacherOne&quot;&gt;&lt;/ref&gt; &lt;/entry&gt; &lt;entry&gt; &lt;key&gt; &lt;value&gt;10086&lt;/value&gt; &lt;/key&gt; &lt;ref bean=&quot;teacherTwo&quot;&gt;&lt;/ref&gt; &lt;/entry&gt;&lt;/util:map&gt;&lt;!--这里students是list集合对象，引用id=students的集合类型的bean--&gt;&lt;bean id=&quot;clazzTwo&quot; class=&quot;com.atguigu.spring6.bean.Clazz&quot;&gt; &lt;property name=&quot;clazzId&quot; value=&quot;4444&quot;&gt;&lt;/property&gt; &lt;property name=&quot;clazzName&quot; value=&quot;Javaee0222&quot;&gt;&lt;/property&gt; &lt;property name=&quot;students&quot; ref=&quot;students&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=&quot;studentFour&quot; class=&quot;com.atguigu.spring6.bean.Student&quot;&gt; &lt;property name=&quot;id&quot; value=&quot;1004&quot;&gt;&lt;/property&gt; &lt;property name=&quot;name&quot; value=&quot;赵六&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;26&quot;&gt;&lt;/property&gt; &lt;property name=&quot;sex&quot; value=&quot;女&quot;&gt;&lt;/property&gt; &lt;!-- ref属性：引用IOC容器中某个bean的id，将所对应的bean为属性赋值 --&gt; &lt;property name=&quot;clazz&quot; ref=&quot;clazzOne&quot;&gt;&lt;/property&gt; &lt;property name=&quot;hobbies&quot;&gt; &lt;array&gt; &lt;value&gt;抽烟&lt;/value&gt; &lt;value&gt;喝酒&lt;/value&gt; &lt;value&gt;烫头&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;property name=&quot;teacherMap&quot; ref=&quot;teacherMap&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 使用util:list、util:map标签必须引入相应的命名空间（在xml文件开头改动） 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xmlns:util=&quot;http://www.springframework.org/schema/util&quot;xsi:schemaLocation=&quot;http://www.springframework.org/schema/utilhttp://www.springframework.org/schema/util/spring-util.xsdhttp://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; p命名空间注入引入p命名空间 xmlns:p=”http://www.springframework.org/schema/p“ 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:util=&quot;http://www.springframework.org/schema/util&quot;xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; 引入p命名空间后，可以通过以下方式为bean的各个属性赋值 12&lt;bean id=&quot;studentSix&quot; class=&quot;com.atguigu.spring6.bean.Student&quot; p:id=&quot;1006&quot; p:name=&quot;小明&quot; p:clazz-ref=&quot;clazzOne&quot; p:teacherMap-ref=&quot;teacherMap&quot;&gt;&lt;/bean&gt; Spring 框架提供了 2 种短命名空间，可以简化 Spring 的 XML 配置，如下表。 短命名空间 简化的 XML 配置 说明p 命名空间 元素中嵌套的 元素 是 setter 方式属性注入的一种快捷实现方式c 命名空间 元素中嵌套的 元素 是构造函数属性注入的一种快捷实现方式 在导入 XML 约束后，我们就能通过以下形式实现属性注入。 引入外部属性文件（如mysql）①加入依赖 12345678910111213 &lt;!-- MySQL驱动 --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.30&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 数据源 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.2.15&lt;/version&gt;&lt;/dependency&gt; ②创建外部属性文件 resource里面创建，properties格式 里面是数据库的配置内容 1234jdbc.user=rootjdbc.password=atguigujdbc.url=jdbc:mysql://localhost:3306/ssm?serverTimezone=UTCjdbc.driver=com.mysql.cj.jdbc.Driver ③引入属性文件 引入context 名称空间 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;&lt;/beans&gt; 12&lt;!-- 引入外部属性文件 --&gt;&lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt; 注意：在使用 元素加载外包配置文件功能前，首先需要在 XML 配置的一级标签 中添加 context 相关的约束。 ④配置bean 123456&lt;bean id=&quot;druidDataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.user&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;&lt;/bean&gt; ⑤测试 1234567@Testpublic void testDataSource() throws SQLException &#123; ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;spring-datasource.xml&quot;); DataSource dataSource = ac.getBean(DataSource.class); Connection connection = dataSource.getConnection(); System.out.println(connection);&#125; bean的作用域（scope）①概念 在Spring中可以通过配置bean标签的scope属性来指定bean的作用域范围，各取值含义参加下表： 取值 含义 创建对象的时机 singleton（默认） 在IOC容器中，这个bean的对象始终为单实例（单例模式）。不写scope默认是单实例。 IOC容器初始化时 prototype 这个bean在IOC容器中有多个实例。 获取bean时 如果是在WebApplicationContext环境下还会有另外几个作用域（但不常用）： 取值 含义 request 在一个请求范围内有效 session 在一个会话范围内有效 ⭐bean的生命周期1、bean对象创建（调用无参构造） 2、bean对象属性注入 3、bean后置处理器 4、对bean对象初始化，调用指定初始化方法 5、bean后置处理器 6、bean对象创建完成了，可以使用了 7、bean对象销毁 8、ioc容器关闭 后置处理器有啥用啊？？ FactoryBeanFactoryBean是Spring提供的一种整合第三方框架的常用机制。和普通的bean不同，配置一个FactoryBean类型的bean，在获取bean的时候得到的并不是class属性中配置的这个类的对象，而是getObject()方法的返回值。通过这种机制，Spring可以帮我们把复杂组件创建的详细过程和繁琐细节都屏蔽起来，只把最简洁的使用界面展示给我们。 将来我们整合Mybatis时，Spring就是通过FactoryBean机制来帮我们创建SqlSessionFactory对象的。 基于xml的自动装配bean标签中有个属性 autowire autowire有两个取值，一个是byType，一个是byName 使用bean标签的autowire属性设置自动装配效果 自动装配方式：byType byType：根据类型匹配IOC容器中的某个兼容类型的bean，为属性自动赋值 若在IOC中，没有任何一个兼容类型的bean能够为属性赋值，则该属性不装配，即值为默认值null 若在IOC中，有多个兼容类型的bean能够为属性赋值，则抛出异常NoUniqueBeanDefinitionException 12345&lt;bean id=&quot;userController&quot; class=&quot;com.atguigu.spring6.autowire.controller.UserController&quot; autowire=&quot;byType&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;userService&quot; class=&quot;com.atguigu.spring6.autowire.service.impl.UserServiceImpl&quot; autowire=&quot;byType&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;userDao&quot; class=&quot;com.atguigu.spring6.autowire.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt; 自动装配方式：byName byName：将自动装配的属性的属性名，作为bean的id在IOC容器中匹配相对应的bean进行赋值 1234567&lt;bean id=&quot;userController&quot; class=&quot;com.atguigu.spring6.autowire.controller.UserController&quot; autowire=&quot;byName&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;userService&quot; class=&quot;com.atguigu.spring6.autowire.service.impl.UserServiceImpl&quot; autowire=&quot;byName&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;userServiceImpl&quot; class=&quot;com.atguigu.spring6.autowire.service.impl.UserServiceImpl&quot; autowire=&quot;byName&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;userDao&quot; class=&quot;com.atguigu.spring6.autowire.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;userDaoImpl&quot; class=&quot;com.atguigu.spring6.autowire.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt; 注意，若是匹配不成功会是空值。 ⭐基于注解方式进行bean管理格式 @注解名称（属性1=属性值…） 使用注解实现xml的自动配置 步骤1引入依赖（maven）2开启组件扫描（配置xml）Spring 默认不使用注解装配 Bean，因此我们需要在 Spring 的 XML 配置中，通过 元素开启 Spring Beans的自动扫描功能。开启此功能后，Spring 会自动从扫描指定的包（base-package 属性设置）及其子包下的所有类，如果类上使用了 @Component 注解，就将该类装配到容器中。 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--开启组件扫描功能--&gt; &lt;context:component-scan base-package=&quot;com.atguigu.spring6&quot;&gt;&lt;/context:component-scan&gt;&lt;/beans&gt; 注意：在使用 元素开启自动扫描功能前，首先需要在 XML 配置的一级标签 中添加 context 相关的约束。 情况一：最基本的扫描方式 12&lt;context:component-scan base-package=&quot;com.atguigu.spring6&quot;&gt;&lt;/context:component-scan&gt; 情况二：指定要排除的组件 12345678910&lt;context:component-scan base-package=&quot;com.atguigu.spring6&quot;&gt; &lt;!-- context:exclude-filter标签：指定排除规则 --&gt; &lt;!-- type：设置排除或包含的依据 type=&quot;annotation&quot;，根据注解排除，expression中设置要排除的注解的全类名 type=&quot;assignable&quot;，根据类型排除，expression中设置要排除的类型的全类名\t--&gt; &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt; &lt;!--&lt;context:exclude-filter type=&quot;assignable&quot; expression=&quot;com.atguigu.spring6.controller.UserController&quot;/&gt;--&gt;&lt;/context:component-scan&gt; 情况三：仅扫描指定组件 123456789101112&lt;context:component-scan base-package=&quot;com.atguigu&quot; use-default-filters=&quot;false&quot;&gt; &lt;!-- context:include-filter标签：指定在原有扫描规则的基础上追加的规则 --&gt; &lt;!-- use-default-filters属性：取值false表示关闭默认扫描规则 --&gt; &lt;!-- 此时必须设置use-default-filters=&quot;false&quot;，因为默认规则即扫描指定包下所有类 --&gt; &lt;!-- type：设置排除或包含的依据 type=&quot;annotation&quot;，根据注解排除，expression中设置要排除的注解的全类名 type=&quot;assignable&quot;，根据类型排除，expression中设置要排除的类型的全类名\t--&gt; &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;\t&lt;!--&lt;context:include-filter type=&quot;assignable&quot; expression=&quot;com.atguigu.spring6.controller.UserController&quot;/&gt;--&gt;&lt;/context:component-scan&gt; 3使用注解Spring 提供了以下多个注解，这些注解可以直接标注在 Java 类上，将它们定义成 Spring Bean。 注解 说明 @Component 该注解用于描述 Spring 中的 Bean，它是一个泛化的概念，仅仅表示容器中的一个组件（Bean），并且可以作用在应用的任何层次，例如 Service 层、Dao 层等。 使用时只需将该注解标注在相应类上即可。 @Repository 该注解用于将数据访问层（Dao 层）的类标识为 Spring 中的 Bean，其功能与 @Component 相同。 @Service 该注解通常作用在业务层（Service 层），用于将业务层的类标识为 Spring 中的 Bean，其功能与 @Component 相同。 @Controller 该注解通常作用在控制层（如SpringMVC 的 Controller），用于将控制层的类标识为 Spring 中的 Bean，其功能与 @Component 相同。 @Autowired注入单独使用@Autowired注解，默认根据类型装配。【默认是byType】 查看源码： 1234567891011121314package org.springframework.beans.factory.annotation;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(&#123;ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.PARAMETER, ElementType.FIELD, ElementType.ANNOTATION_TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface Autowired &#123; boolean required() default true;&#125; 源码中有两处需要注意： 第一处：该注解可以标注在哪里？ 构造方法上 方法上 形参上 属性上 注解上 第二处：该注解有一个required属性，默认值是true，表示在注入的时候要求被注入的Bean必须是存在的，如果不存在则报错。如果required属性设置为false，表示注入的Bean存在或者不存在都没关系，存在的话就注入，不存在的话，也不报错。 成员属性注入1、使用注解创建需要的bean对象 @Servicepublic class UserService implements UserServiceI{… } 2、 在属性上使用@Autowired进行对象的注入 set注入 生成set方法，在set方法上标注@Autowired 构造方法上进行注入在构造方法上加注解；（仅有一个构造函数时，可以省略注解） 形参上注入 @Autowired注解和@Qualifier注解联合当一个接口有多个实现类时，需要结合Qualifier标签，指定具体是哪个实现类。 这里UserDao是接口。 注意这里首字母需要小写 @Resource注入@Resource注解也可以完成属性注入。那它和@Autowired注解有什么区别？ @Resource注解是JDK扩展包中的，也就是说属于JDK的一部分。所以该注解是标准注解，更加具有通用性。(JSR-250标准中制定的注解类型。JSR是Java规范提案。) @Autowired注解是Spring框架自己的。 @Resource注解默认根据名称装配byName，未指定name时，使用属性名作为name。通过name找不到的话会自动启动通过类型byType装配。 @Autowired注解默认根据类型装配byType，如果想根据名称装配，需要配合@Qualifier注解一起用。 @Resource注解用在属性上、setter方法上。 @Autowired注解用在属性上、setter方法上、构造方法上、构造方法参数上。 @Resource注解属于JDK扩展包，所以不在JDK当中，需要额外引入以下依赖：【如果是JDK8的话不需要额外引入依赖。高于JDK11或低于JDK8需要引入以下依赖。】 12345&lt;dependency&gt; &lt;groupId&gt;jakarta.annotation&lt;/groupId&gt; &lt;artifactId&gt;jakarta.annotation-api&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt;&lt;/dependency&gt; ①场景一：根据name注入修改UserDaoImpl类 12345678910111213package com.atguigu.spring6.dao.impl;import com.atguigu.spring6.dao.UserDao;import org.springframework.stereotype.Repository;@Repository(&quot;myUserDao&quot;)//这里加上value，可省略valuepublic class UserDaoImpl implements UserDao &#123; @Override public void print() &#123; System.out.println(&quot;Dao层执行结束&quot;); &#125;&#125; 修改UserServiceImpl类 123456789101112131415161718192021package com.atguigu.spring6.service.impl;import com.atguigu.spring6.dao.UserDao;import com.atguigu.spring6.service.UserService;import jakarta.annotation.Resource;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.stereotype.Service;@Servicepublic class UserServiceImpl implements UserService &#123; @Resource(name = &quot;myUserDao&quot;)//和上面加的一样 private UserDao myUserDao; @Override public void out() &#123; myUserDao.print(); System.out.println(&quot;Service层执行结束&quot;); &#125;&#125; 测试通过 ②场景二：name未知注入修改UserDaoImpl类 12345678910111213package com.atguigu.spring6.dao.impl;import com.atguigu.spring6.dao.UserDao;import org.springframework.stereotype.Repository;@Repository(&quot;myUserDao&quot;)public class UserDaoImpl implements UserDao &#123; @Override public void print() &#123; System.out.println(&quot;Dao层执行结束&quot;); &#125;&#125; 修改UserServiceImpl类 123456789101112131415161718192021package com.atguigu.spring6.service.impl;import com.atguigu.spring6.dao.UserDao;import com.atguigu.spring6.service.UserService;import jakarta.annotation.Resource;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.stereotype.Service;@Servicepublic class UserServiceImpl implements UserService &#123; @Resource private UserDao myUserDao;//使属性名字与之前的bean对象名字一样myUserDao；不指定名称就按照属性名字进行注入 @Override public void out() &#123; myUserDao.print(); System.out.println(&quot;Service层执行结束&quot;); &#125;&#125; 测试通过 当@Resource注解使用时没有指定name的时候，还是根据name进行查找，这个name是属性名。 ③场景三 其他情况，根据类型注入修改UserServiceImpl类，userDao1属性名不存在 123456789101112131415161718192021package com.atguigu.spring6.service.impl;import com.atguigu.spring6.dao.UserDao;import com.atguigu.spring6.service.UserService;import jakarta.annotation.Resource;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.stereotype.Service;@Servicepublic class UserServiceImpl implements UserService &#123; @Resource private UserDao userDao1;//找不到名字，就用类型注入 @Override public void out() &#123; userDao1.print(); System.out.println(&quot;Service层执行结束&quot;); &#125;&#125; 测试异常 根据异常信息得知：显然当通过name找不到的时候，自然会启动byType进行注入，以上的错误是因为UserDao接口下有两个实现类导致的。所以根据类型注入就会报错。 @Resource的set注入可以自行测试 总结： @Resource注解：默认byName注入，没有指定name时把属性名当做name，根据name找不到时，才会byType注入。byType注入时，某种类型的Bean只能有一个 全注解开发（无需创建xml文件）全注解开发就是不再使用spring配置文件了，写一个配置类来代替配置文件。 12345678910package com.atguigu.spring6.config;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@Configuration //使用注解，声明这个类是一个配置类//@ComponentScan(&#123;&quot;com.atguigu.spring6.controller&quot;, &quot;com.atguigu.spring6.service&quot;,&quot;com.atguigu.spring6.dao&quot;&#125;)@ComponentScan(&quot;com.atguigu.spring6&quot;)//指定扫描的包的路径public class Spring6Config &#123;&#125; 测试类要修改一点 1234567@Testpublic void testAllAnnotation()&#123; ApplicationContext context = new AnnotationConfigApplicationContext(Spring6Config.class);//这里要改，其他一样 UserController userController = context.getBean(&quot;userController&quot;, UserController.class); userController.out(); logger.info(&quot;执行成功&quot;);&#125; IOC原理java中的反射机制Java反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为Java语言的反射机制。简单来说，反射机制指的是程序在运行时能够获取自身的信息。 要想解剖一个类，必须先要获取到该类的Class对象。而剖析一个类或用反射解决具体的问题就是使用相关API（1）java.lang.Class（2）java.lang.reflect，所以，Class对象是反射的根源。 获取Class对象多种方式 12345678910111213141516//1、获取Class对象多种方式 @Test public void test01() throws Exception &#123; //1 类名.class Class clazz1 = Car.class; //2 对象.getClass() Class clazz2 = new Car().getClass(); //3 Class.forName(&quot;全路径&quot;) Class clazz3 = Class.forName(&quot;com.atguigu.reflect.Car&quot;); //实例化 Car car = (Car)clazz3.getConstructor().newInstance(); System.out.println(car); &#125; class实例化 123//实例化 Car car = (Car)clazz3.getConstructor().newInstance(); System.out.println(car); 通过反射获取构造方法 12345678910public void test02() throws Exception &#123; Class clazz = Car.class; //获取所有构造 // getConstructors()获取所有public的构造方法\t// Constructor[] constructors = clazz.getConstructors(); // getDeclaredConstructors()获取所有的构造方法public private Constructor[] constructors = clazz.getDeclaredConstructors(); for (Constructor c:constructors) &#123; System.out.println(&quot;方法名称：&quot;+c.getName()+&quot; 参数个数：&quot;+c.getParameterCount()); &#125; 通过有参数构造创建实例 123456789101112//指定有参数构造创建对象 //1 构造方法是public Constructor c1 = clazz.getConstructor(String.class, int.class, String.class);//这个根据有参构造的参数列表，填对应的.class Car car1 = (Car)c1.newInstance(&quot;夏利&quot;, 10, &quot;红色&quot;); System.out.println(car1); //2 构造方法是private Constructor c2 = clazz.getDeclaredConstructor(String.class, int.class, String.class); c2.setAccessible(true); Car car2 = (Car)c2.newInstance(&quot;捷达&quot;, 15, &quot;白色&quot;); System.out.println(car2); &#125; 获取属性 12345678910111213141516171819//3、获取属性 @Test public void test03() throws Exception &#123; Class clazz = Car.class; Car car = (Car)clazz.getDeclaredConstructor().newInstance();//这里是实例化 //获取所有public属性 //Field[] fields = clazz.getFields(); //获取所有属性（包含私有属性） Field[] fields = clazz.getDeclaredFields(); for (Field field:fields) &#123; if(field.getName().equals(&quot;name&quot;)) &#123; //设置允许访问 field.setAccessible(true); field.set(car,&quot;五菱宏光&quot;);//为car实例赋值 System.out.println(car); &#125; System.out.println(field.getName());//输出属性的名字 &#125; &#125; 操纵方法 123456789101112131415//4、获取方法 @Test public void test04() throws Exception &#123; Car car = new Car(&quot;奔驰&quot;,10,&quot;黑色&quot;);//实例化的对象 Class clazz = car.getClass(); //1 public方法 Method[] methods = clazz.getMethods(); for (Method m1:methods) &#123; //System.out.println(m1.getName());//输出方法的名字 //执行方法 toString if(m1.getName().equals(&quot;toString&quot;)) &#123; String invoke = (String)m1.invoke(car); //System.out.println(&quot;toString执行了：&quot;+invoke); &#125; &#125; 123456789//2 private方法 Method[] methodsAll = clazz.getDeclaredMethods(); for (Method m:methodsAll) &#123; //执行方法 run if(m.getName().equals(&quot;run&quot;)) &#123; m.setAccessible(true); m.invoke(car); &#125; &#125; 实现spring的IoC（跳过了，暂时没看，这里是源码讲解）自定义两个注解Bean Di，通过bean创建对象，通过Di实现注入。 创建容器接口 实现接口，返回对象；根据包规则扫描， 自定义注解上有两个元注解，一个是 @Target(ElementType.TYPE)//什么地方能用@Retention(RetentionPolicy.RUNTIME)//作用范围，运行时生效 bean注解 1234567891011package com.atguigu.spring.core.annotation;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface Bean &#123;&#125; 依赖注入注解 1234567891011package com.atguigu.spring.core.annotation;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(&#123;ElementType.FIELD&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface Di &#123;&#125; 说明：上面两个注解可以随意取名 建立容器接口 ④定义bean容器接口 123456package com.atguigu.spring.core;public interface ApplicationContext &#123; Object getBean(Class clazz);&#125; ⑤编写注解bean容器接口实现 AnnotationApplicationContext基于注解扫描bean 12345678910111213141516171819202122package com.atguigu.spring.core;import java.util.HashMap;public class AnnotationApplicationContext implements ApplicationContext &#123; //存储bean的容器 private HashMap&lt;Class, Object&gt; beanFactory = new HashMap&lt;&gt;(); @Override public Object getBean(Class clazz) &#123; return beanFactory.get(clazz); &#125; /** * 根据包扫描加载bean * @param basePackage */ public AnnotationApplicationContext(String basePackage) &#123; &#125;&#125; ⑥编写扫描bean逻辑 我们通过构造方法传入包的base路径，扫描被@Bean注解的java对象，完整代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package com.atguigu.spring.core;import com.atguigu.spring.core.annotation.Bean;import java.io.File;import java.util.HashMap;public class AnnotationApplicationContext implements ApplicationContext &#123; //存储bean的容器 private HashMap&lt;Class, Object&gt; beanFactory = new HashMap&lt;&gt;(); private static String rootPath; @Override public Object getBean(Class clazz) &#123; return beanFactory.get(clazz); &#125; /** * 根据包扫描加载bean * @param basePackage */ public AnnotationApplicationContext(String basePackage) &#123; try &#123; String packageDirName = basePackage.replaceAll(&quot;\\\\.&quot;, &quot;\\\\\\\\&quot;); Enumeration&lt;URL&gt; dirs =Thread.currentThread().getContextClassLoader().getResources(packageDirName); while (dirs.hasMoreElements()) &#123; URL url = dirs.nextElement(); String filePath = URLDecoder.decode(url.getFile(),&quot;utf-8&quot;); rootPath = filePath.substring(0, filePath.length()-packageDirName.length()); loadBean(new File(filePath)); &#125; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; private void loadBean(File fileParent) &#123;//完成包的扫描过程 if (fileParent.isDirectory()) &#123; File[] childrenFiles = fileParent.listFiles(); if(childrenFiles == null || childrenFiles.length == 0)&#123; return; &#125; for (File child : childrenFiles) &#123;//获取文件夹所有内容 if (child.isDirectory()) &#123; //如果是个文件夹就继续调用该方法,使用了递归 loadBean(child); &#125; else &#123; //通过文件路径转变成全类名,第一步把绝对路径部分去掉 String pathWithClass = child.getAbsolutePath().substring(rootPath.length() - 1); //选中class文件 if (pathWithClass.contains(&quot;.class&quot;)) &#123; // com.xinzhi.dao.UserDao //去掉.class后缀，并且把 \\ 替换成 . String fullName = pathWithClass.replaceAll(&quot;\\\\\\\\&quot;, &quot;.&quot;).replace(&quot;.class&quot;, &quot;&quot;); try &#123; Class&lt;?&gt; aClass = Class.forName(fullName); //把非接口的类实例化放在map中 if(!aClass.isInterface())&#123; Bean annotation = aClass.getAnnotation(Bean.class); if(annotation != null)&#123; Object instance = aClass.newInstance(); //判断一下有没有接口 if(aClass.getInterfaces().length &gt; 0) &#123; //如果有接口把接口的class当成key，实例对象当成value System.out.println(&quot;正在加载【&quot;+ aClass.getInterfaces()[0] +&quot;】,实例对象是：&quot; + instance.getClass().getName()); beanFactory.put(aClass.getInterfaces()[0], instance); &#125;else&#123; //如果有接口把自己的class当成key，实例对象当成value System.out.println(&quot;正在加载【&quot;+ aClass.getName() +&quot;】,实例对象是：&quot; + instance.getClass().getName()); beanFactory.put(aClass, instance); &#125; &#125; &#125; &#125; catch (ClassNotFoundException | IllegalAccessException | InstantiationException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; &#125;&#125; ⑦java类标识Bean注解 12@Beanpublic class UserServiceImpl implements UserService 12@Beanpublic class UserDaoImpl implements UserDao ⑧测试Bean加载 1234567891011121314151617package com.atguigu.spring;import com.atguigu.spring.core.AnnotationApplicationContext;import com.atguigu.spring.core.ApplicationContext;import com.atguigu.spring.test.service.UserService;import org.junit.jupiter.api.Test;public class SpringIocTest &#123; @Test public void testIoc() &#123; ApplicationContext applicationContext = new AnnotationApplicationContext(&quot;com.atguigu.spring.test&quot;); UserService userService = (UserService)applicationContext.getBean(UserService.class); userService.out(); System.out.println(&quot;run success&quot;); &#125;&#125; 控制台打印测试 ⑨依赖注入 只要userDao.print();调用成功，说明就注入成功 12345678910111213141516171819package com.atguigu.spring.test.service.impl;import com.atguigu.spring.core.annotation.Bean;import com.atguigu.spring.core.annotation.Di;import com.atguigu.spring.dao.UserDao;import com.atguigu.spring.service.UserService;@Beanpublic class UserServiceImpl implements UserService &#123; @Di private UserDao userDao; @Override public void out() &#123; userDao.print(); System.out.println(&quot;Service层执行结束&quot;); &#125;&#125; 执行第八步：报错了，说明当前userDao是个空对象 ⑩依赖注入实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112package com.atguigu.spring.core;import com.atguigu.spring.core.annotation.Bean;import com.atguigu.spring.core.annotation.Di;import java.io.File;import java.lang.reflect.Field;import java.util.HashMap;import java.util.Map;public class AnnotationApplicationContext implements ApplicationContext &#123; //存储bean的容器 private HashMap&lt;Class, Object&gt; beanFactory = new HashMap&lt;&gt;(); private static String rootPath; @Override public Object getBean(Class clazz) &#123; return beanFactory.get(clazz); &#125; /** * 根据包扫描加载bean * @param basePackage */ public AnnotationApplicationContext(String basePackage) &#123; try &#123; String packageDirName = basePackage.replaceAll(&quot;\\\\.&quot;, &quot;\\\\\\\\&quot;); Enumeration&lt;URL&gt; dirs =Thread.currentThread().getContextClassLoader().getResources(packageDirName); while (dirs.hasMoreElements()) &#123; URL url = dirs.nextElement(); String filePath = URLDecoder.decode(url.getFile(),&quot;utf-8&quot;); rootPath = filePath.substring(0, filePath.length()-packageDirName.length()); loadBean(new File(filePath)); &#125; &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; //依赖注入 loadDi(); &#125; private void loadBean(File fileParent) &#123; if (fileParent.isDirectory()) &#123; File[] childrenFiles = fileParent.listFiles(); if(childrenFiles == null || childrenFiles.length == 0)&#123; return; &#125; for (File child : childrenFiles) &#123; if (child.isDirectory()) &#123; //如果是个文件夹就继续调用该方法,使用了递归 loadBean(child); &#125; else &#123; //通过文件路径转变成全类名,第一步把绝对路径部分去掉 String pathWithClass = child.getAbsolutePath().substring(rootPath.length() - 1); //选中class文件 if (pathWithClass.contains(&quot;.class&quot;)) &#123; // com.xinzhi.dao.UserDao //去掉.class后缀，并且把 \\ 替换成 . String fullName = pathWithClass.replaceAll(&quot;\\\\\\\\&quot;, &quot;.&quot;).replace(&quot;.class&quot;, &quot;&quot;); try &#123; Class&lt;?&gt; aClass = Class.forName(fullName); //把非接口的类实例化放在map中 if(!aClass.isInterface())&#123; Bean annotation = aClass.getAnnotation(Bean.class); if(annotation != null)&#123; Object instance = aClass.newInstance(); //判断一下有没有接口 if(aClass.getInterfaces().length &gt; 0) &#123; //如果有接口把接口的class当成key，实例对象当成value System.out.println(&quot;正在加载【&quot;+ aClass.getInterfaces()[0] +&quot;】,实例对象是：&quot; + instance.getClass().getName()); beanFactory.put(aClass.getInterfaces()[0], instance); &#125;else&#123; //如果有接口把自己的class当成key，实例对象当成value System.out.println(&quot;正在加载【&quot;+ aClass.getName() +&quot;】,实例对象是：&quot; + instance.getClass().getName()); beanFactory.put(aClass, instance); &#125; &#125; &#125; &#125; catch (ClassNotFoundException | IllegalAccessException | InstantiationException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; &#125; private void loadDi() &#123; for(Map.Entry&lt;Class,Object&gt; entry : beanFactory.entrySet())&#123; //就是咱们放在容器的对象 Object obj = entry.getValue(); Class&lt;?&gt; aClass = obj.getClass(); Field[] declaredFields = aClass.getDeclaredFields(); for (Field field : declaredFields)&#123; Di annotation = field.getAnnotation(Di.class); if( annotation != null )&#123; field.setAccessible(true); try &#123; System.out.println(&quot;正在给【&quot;+obj.getClass().getName()+&quot;】属性【&quot; + field.getName() + &quot;】注入值【&quot;+ beanFactory.get(field.getType()).getClass().getName() +&quot;】&quot;); field.set(obj,beanFactory.get(field.getType())); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125;&#125; 执行第八步：执行成功，依赖注入成功 ⭐AOP面向切面编程5.1、场景模拟这里模拟一个计算器，可以实现加减乘除 搭建子模块：spring6-aop 5.1.1、声明接口声明计算器接口Calculator，包含加减乘除的抽象方法 1234567891011public interface Calculator &#123; int add(int i, int j); int sub(int i, int j); int mul(int i, int j); int div(int i, int j); &#125; 5.1.2、创建实现类 123456789101112131415161718192021222324252627282930313233343536373839404142public class CalculatorImpl implements Calculator &#123; @Override public int add(int i, int j) &#123; int result = i + j; System.out.println(&quot;方法内部 result = &quot; + result); return result; &#125; @Override public int sub(int i, int j) &#123; int result = i - j; System.out.println(&quot;方法内部 result = &quot; + result); return result; &#125; @Override public int mul(int i, int j) &#123; int result = i * j; System.out.println(&quot;方法内部 result = &quot; + result); return result; &#125; @Override public int div(int i, int j) &#123; int result = i / j; System.out.println(&quot;方法内部 result = &quot; + result); return result; &#125;&#125; 5.1.3、创建带日志功能的实现类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class CalculatorLogImpl implements Calculator &#123; @Override public int add(int i, int j) &#123; System.out.println(&quot;[日志] add 方法开始了，参数是：&quot; + i + &quot;,&quot; + j); int result = i + j; System.out.println(&quot;方法内部 result = &quot; + result); System.out.println(&quot;[日志] add 方法结束了，结果是：&quot; + result); return result; &#125; @Override public int sub(int i, int j) &#123; System.out.println(&quot;[日志] sub 方法开始了，参数是：&quot; + i + &quot;,&quot; + j); int result = i - j; System.out.println(&quot;方法内部 result = &quot; + result); System.out.println(&quot;[日志] sub 方法结束了，结果是：&quot; + result); return result; &#125; @Override public int mul(int i, int j) &#123; System.out.println(&quot;[日志] mul 方法开始了，参数是：&quot; + i + &quot;,&quot; + j); int result = i * j; System.out.println(&quot;方法内部 result = &quot; + result); System.out.println(&quot;[日志] mul 方法结束了，结果是：&quot; + result); return result; &#125; @Override public int div(int i, int j) &#123; System.out.println(&quot;[日志] div 方法开始了，参数是：&quot; + i + &quot;,&quot; + j); int result = i / j; System.out.println(&quot;方法内部 result = &quot; + result); System.out.println(&quot;[日志] div 方法结束了，结果是：&quot; + result); return result; &#125;&#125; 5.1.4、提出问题①现有代码缺陷 针对带日志功能的实现类，我们发现有如下缺陷： 对核心业务功能有干扰，导致程序员在开发核心业务功能时分散了精力（日志和核心功能是混合在一起的） 附加功能分散在各个业务功能方法中，不利于统一维护 ②解决思路 解决这两个问题，核心就是：解耦。我们需要把附加功能从业务功能代码中抽取出来。 ③困难 解决问题的困难：要抽取的代码在方法内部，靠以前把子类中的重复代码抽取到父类的方式没法解决。所以需要引入新的技术。 5.2、代理模式5.2.1、概念①介绍 二十三种设计模式中的一种，属于结构型模式。它的作用就是通过提供一个代理类，让我们在调用目标方法的时候，不再是直接对目标方法进行调用，而是通过代理类间接调用。让不属于目标方法核心逻辑的代码从目标方法中剥离出来——解耦。调用目标方法时先调用代理对象的方法，减少对目标方法的调用和打扰，同时让附加功能能够集中在一起也有利于统一维护。 使用代理后： ②生活中的代理 广告商找大明星拍广告需要经过经纪人 合作伙伴找大老板谈合作要约见面时间需要经过秘书 房产中介是买卖双方的代理 ③相关术语 代理：将非核心逻辑剥离出来以后，封装这些非核心逻辑的类、对象、方法。 目标：被代理“套用”了非核心逻辑代码的类、对象、方法。 5.2.2、静态代理创建静态代理类： 1234567891011121314151617181920212223public class CalculatorStaticProxy implements Calculator &#123; // 将被代理的目标对象声明为成员变量 private Calculator target; public CalculatorStaticProxy(Calculator target) &#123; this.target = target; &#125; @Override public int add(int i, int j) &#123; // 附加功能由代理类中的代理方法来实现 System.out.println(&quot;[日志] add 方法开始了，参数是：&quot; + i + &quot;,&quot; + j); // 通过目标对象来实现核心业务逻辑 int addResult = target.add(i, j); System.out.println(&quot;[日志] add 方法结束了，结果是：&quot; + addResult); return addResult; &#125;&#125; 静态代理确实实现了解耦，但是由于代码都写死了，完全不具备任何的灵活性。就拿日志功能来说，将来其他地方也需要附加日志，那还得再声明更多个静态代理类，那就产生了大量重复的代码，日志功能还是分散的，没有统一管理。 提出进一步的需求：将日志功能集中到一个代理类中，将来有任何日志需求，都通过这一个代理类来实现。这就需要使用动态代理技术了。 5.2.3、动态代理spring底层就是动态代理 生产代理对象的工厂类： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class ProxyFactory &#123; private Object target; public ProxyFactory(Object target) &#123; this.target = target; &#125; public Object getProxy()&#123; /** * newProxyInstance()：创建一个代理实例 * 其中有三个参数： * 1、classLoader：加载动态生成的代理类的类加载器 * 2、interfaces：目标对象实现的所有接口的class对象所组成的数组 * 3、invocationHandler：设置代理对象实现目标对象方法的过程，即代理类中如何重写接口中的抽象方法 */ ClassLoader classLoader = target.getClass().getClassLoader(); Class&lt;?&gt;[] interfaces = target.getClass().getInterfaces(); InvocationHandler invocationHandler = new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; /** * proxy：代理对象 * method：代理对象需要实现的方法，即其中需要重写的方法 * args：method所对应方法的参数 */ Object result = null; try &#123; //日志功能1 System.out.println(&quot;[动态代理][日志] &quot;+method.getName()+&quot;，参数：&quot;+ Arrays.toString(args)); result = method.invoke(target, args);//调用目标方法（核心功能） //日志功能2 System.out.println(&quot;[动态代理][日志] &quot;+method.getName()+&quot;，结果：&quot;+ result); &#125; catch (Exception e) &#123; e.printStackTrace(); System.out.println(&quot;[动态代理][日志] &quot;+method.getName()+&quot;，异常：&quot;+e.getMessage()); &#125; finally &#123; System.out.println(&quot;[动态代理][日志] &quot;+method.getName()+&quot;，方法执行完毕&quot;); &#125; return result; &#125; &#125;; return Proxy.newProxyInstance(classLoader, interfaces, invocationHandler);//返回代理对象 &#125;&#125; 5.2.4、测试1234567@Testpublic void testDynamicProxy()&#123; ProxyFactory factory = new ProxyFactory(new CalculatorLogImpl()); Calculator proxy = (Calculator) factory.getProxy(); proxy.div(1,0); //proxy.div(1,1);&#125; 5.3、AOP概念及相关术语5.3.1、概述AOP的底层是动态代理。 AOP（Aspect Oriented Programming）是一种设计思想，是软件设计领域中的面向切面编程，它是面向对象编程的一种补充和完善，它以通过预编译方式和运行期动态代理方式实现，在不修改源代码的情况下，给程序动态统一添加额外功能的一种技术。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 5.3.2、相关术语①横切关注点（非核心业务）分散在每个各个模块中解决同一样的问题，如用户验证、日志管理、事务处理、数据缓存都属于横切关注点。 从每个方法中抽取出来的同一类非核心业务。在同一个项目中，我们可以使用多个横切关注点对相关方法进行多个不同方面的增强。 这个概念不是语法层面的，而是根据附加功能的逻辑上的需要：有十个附加功能，就有十个横切关注点。 ②通知（增强）增强，通俗说，就是你想要增强的功能，比如 安全，事务，日志等。 每一个横切关注点上要做的事情都需要写一个方法来实现，这样的方法就叫通知方法。 前置通知：在被代理的目标方法前执行 返回通知：在被代理的目标方法成功结束后执行（寿终正寝） 异常通知：在被代理的目标方法异常结束后执行（死于非命） 后置通知：在被代理的目标方法最终结束后执行（盖棺定论） 环绕通知：使用try…catch…finally结构围绕整个被代理的目标方法，包括上面四种通知对应的所有位置 ③切面封装通知方法的类。 ④目标被代理的目标对象。 ⑤代理向目标对象应用通知之后创建的代理对象。 ⑥连接点这也是一个纯逻辑概念，不是语法定义的。 把方法排成一排，每一个横切位置看成x轴方向，把方法从上到下执行的顺序看成y轴，x轴和y轴的交叉点就是连接点。通俗说，就是spring允许你使用通知的地方 ⑦切入点定位连接点的方式。 每个类的方法中都包含多个连接点，所以连接点是类中客观存在的事物（从逻辑上来说）。 如果把连接点看作数据库中的记录，那么切入点就是查询记录的 SQL 语句。 Spring 的 AOP 技术可以通过切入点定位到特定的连接点。通俗说，要实际去增强的方法 切点通过 org.springframework.aop.Pointcut 接口进行描述，它使用类和方法作为连接点的查询条件。 5.3.3、作用 简化代码：把方法中固定位置的重复的代码抽取出来，让被抽取的方法更专注于自己的核心功能，提高内聚性。 代码增强：把特定的功能封装到切面类中，看哪里有需要，就往上套，被套用了切面逻辑的方法就被切面给增强了。 ⭐5.4、基于注解的AOP5.4.1、技术说明动态代理分两类 ​ 指向jdk 指向CGLib 动态代理分为JDK动态代理和cglib动态代理 当目标类有接口的情况使用JDK动态代理和cglib动态代理，没有接口时只能使用cglib动态代理 JDK动态代理动态生成的代理类会在com.sun.proxy包下，类名为$proxy1，和目标类实现相同的接口 cglib动态代理动态生成的代理类会和目标在在相同的包下，会继承目标类 动态代理（InvocationHandler）：JDK原生的实现方式，需要被代理的目标类必须实现接口。因为这个技术要求代理对象和目标对象实现同样的接口（兄弟两个拜把子模式）。 cglib：通过继承被代理的目标类（认干爹模式）实现代理，所以不需要目标类实现接口。 AspectJ：是AOP思想的一种实现。本质上是静态代理，将代理逻辑“织入”被代理的目标类编译得到的字节码文件，所以最终效果是动态的。weaver就是织入器。Spring只是借用了AspectJ中的注解。 5.4.2、准备工作①添加依赖 在IOC所需依赖基础上再加入下面依赖即可： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;dependencies&gt; &lt;!--spring context依赖--&gt; &lt;!--当你引入Spring Context依赖之后，表示将Spring的基础依赖引入了--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;6.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--spring aop依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;6.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--spring aspects依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;6.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--junit5测试--&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt; &lt;version&gt;5.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!--log4j2的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;version&gt;2.19.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-slf4j2-impl&lt;/artifactId&gt; &lt;version&gt;2.19.0&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; ②准备被代理的目标资源 接口： 1234567891011public interface Calculator &#123; int add(int i, int j); int sub(int i, int j); int mul(int i, int j); int div(int i, int j); &#125; 实现类： 12345678910111213141516171819202122232425262728293031323334353637383940414243@Component //这个是要的public class CalculatorImpl implements Calculator &#123; @Override public int add(int i, int j) &#123; int result = i + j; System.out.println(&quot;方法内部 result = &quot; + result); return result; &#125; @Override public int sub(int i, int j) &#123; int result = i - j; System.out.println(&quot;方法内部 result = &quot; + result); return result; &#125; @Override public int mul(int i, int j) &#123; int result = i * j; System.out.println(&quot;方法内部 result = &quot; + result); return result; &#125; @Override public int div(int i, int j) &#123; int result = i / j; System.out.println(&quot;方法内部 result = &quot; + result); return result; &#125;&#125; 5.4.3、创建切面类并配置（好处：完全解耦了，修改非核心业务的代码完全与核心业务代码无关） 12345678910111213141516// @Aspect表示这个类是一个切面类@Aspect// @Component注解保证这个切面类能够放入IOC容器@Componentpublic class LogAspect &#123; //设置切入点和通知类型（有5种） //在方法前加上注解，注解里放切入点表达式 @Before(&quot;execution(public int com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;)//切入点表达式；配置切入点 public void beforeMethod(JoinPoint joinPoint)&#123; String methodName = joinPoint.getSignature().getName(); String args = Arrays.toString(joinPoint.getArgs()); System.out.println(&quot;Logger--&gt;前置通知，方法名：&quot;+methodName+&quot;，参数：&quot;+args); &#125; 12//切入点表达式 &quot;execution(权限修饰符 方法返回值 方法全类名 方法名(参数列表))&quot; 1234567891011121314151617181920212223242526272829303132333435363738 @After(&quot;execution(* com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;) public void afterMethod(JoinPoint joinPoint)&#123; String methodName = joinPoint.getSignature().getName(); System.out.println(&quot;Logger--&gt;后置通知，方法名：&quot;+methodName); &#125;\t//后置通知在返回通知之后执行，返回通知能得到返回值。 @AfterReturning(value = &quot;execution(* com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;, returning = &quot;result&quot;) public void afterReturningMethod(JoinPoint joinPoint, Object result)&#123;//这里变量名要与注解里一样 String methodName = joinPoint.getSignature().getName(); System.out.println(&quot;Logger--&gt;返回通知，方法名：&quot;+methodName+&quot;，结果：&quot;+result); &#125;\t//目标方法出现异常,这个方法执行 @AfterThrowing(value = &quot;execution(* com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;, throwing = &quot;ex&quot;) public void afterThrowingMethod(JoinPoint joinPoint, Throwable ex)&#123; String methodName = joinPoint.getSignature().getName(); System.out.println(&quot;Logger--&gt;异常通知，方法名：&quot;+methodName+&quot;，异常：&quot;+ex); &#125; //环绕通知，使用try catch finally 实现在不同时间点进行通知 @Around(&quot;execution(* com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;) public Object aroundMethod(ProceedingJoinPoint joinPoint)&#123; String methodName = joinPoint.getSignature().getName(); String args = Arrays.toString(joinPoint.getArgs()); Object result = null; try &#123; System.out.println(&quot;环绕通知--&gt;目标对象方法执行之前&quot;); //目标对象（连接点）方法的执行 result = joinPoint.proceed(); System.out.println(&quot;环绕通知--&gt;目标对象方法返回值之后&quot;); &#125; catch (Throwable throwable) &#123; throwable.printStackTrace(); System.out.println(&quot;环绕通知--&gt;目标对象方法出现异常时&quot;); &#125; finally &#123; System.out.println(&quot;环绕通知--&gt;目标对象方法执行完毕&quot;); &#125; return result; &#125; &#125; 在Spring的配置文件中配置： 123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!-- 基于注解的AOP的实现： 1、将目标对象和切面交给IOC容器管理（注解+扫描） 2、开启AspectJ的自动代理，为目标对象自动生成代理 3、将切面类通过注解@Aspect标识 --&gt; &lt;context:component-scan base-package=&quot;com.atguigu.aop.annotation&quot;&gt;&lt;/context:component-scan&gt;\t&lt;!--开启aspectj自动代理，为目标对象生成代理--&gt; &lt;aop:aspectj-autoproxy /&gt;&lt;/beans&gt; 执行测试： 12345678910111213public class CalculatorTest &#123; private Logger logger = LoggerFactory.getLogger(CalculatorTest.class); @Test public void testAdd()&#123; ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); Calculator calculator = ac.getBean( Calculator.class); int add = calculator.add(1, 1); logger.info(&quot;执行成功:&quot;+add); &#125;&#125; 执行结果： 5.4.4、各种通知 前置通知：使用@Before注解标识，在被代理的目标方法前执行 返回通知：使用@AfterReturning注解标识，在被代理的目标方法成功结束后执行（寿终正寝） 异常通知：使用@AfterThrowing注解标识，在被代理的目标方法异常结束后执行（死于非命） 后置通知：使用@After注解标识，在被代理的目标方法最终结束后执行（盖棺定论） 环绕通知：使用@Around注解标识，使用try…catch…finally结构围绕整个被代理的目标方法，包括上面四种通知对应的所有位置 各种通知的执行顺序： Spring版本5.3.x以前： 前置通知 目标操作 后置通知 返回通知或异常通知 Spring版本5.3.x以后： 前置通知 目标操作 返回通知或异常通知 后置通知 ⭐5.4.5、切入点表达式语法①作用 ②语法细节 用*号代替“权限修饰符”和“返回值”部分表示“权限修饰符”和“返回值”不限 在包名的部分，一个“*”号只能代表包的层次结构中的一层，表示这一层是任意的。 例如：*.Hello匹配com.Hello，不匹配com.atguigu.Hello 在包名的部分，使用“*..”表示包名任意、包的层次深度任意 在类名的部分，类名部分整体用*号代替，表示类名任意 在类名的部分，可以使用*号代替类名的一部分 例如：*Service匹配所有名称以Service结尾的类或接口 在方法名部分，可以使用*号表示方法名任意 在方法名部分，可以使用*号代替方法名的一部分 例如：*Operation匹配所有方法名以Operation结尾的方法 在方法参数列表部分，使用(..)表示参数列表任意 在方法参数列表部分，使用(int,..)表示参数列表以一个int类型的参数开头 在方法参数列表部分，基本数据类型和对应的包装类型是不一样的 切入点表达式中使用 int 和实际方法中 Integer 是不匹配的 在方法返回值部分，如果想要明确指定一个返回值类型，那么必须同时写明权限修饰符 例如：execution(public int ..Service.(.., int)) 正确例如：execution( int ..Service.*(.., int)) 错误 5.4.6、重用（复用、重复用）切入点表达式如何只用写一次切入点表达式 ①声明 12@Pointcut(&quot;execution(* com.atguigu.aop.annotation.*.*(..))&quot;)public void pointCut()&#123;&#125; ②在同一个切面中使用 123456@Before(&quot;pointCut()&quot;)public void beforeMethod(JoinPoint joinPoint)&#123; String methodName = joinPoint.getSignature().getName(); String args = Arrays.toString(joinPoint.getArgs()); System.out.println(&quot;Logger--&gt;前置通知，方法名：&quot;+methodName+&quot;，参数：&quot;+args);&#125; ③在不同切面中使用 123456@Before(&quot;com.atguigu.aop.CommonPointCut.pointCut()&quot;)public void beforeMethod(JoinPoint joinPoint)&#123; String methodName = joinPoint.getSignature().getName(); String args = Arrays.toString(joinPoint.getArgs()); System.out.println(&quot;Logger--&gt;前置通知，方法名：&quot;+methodName+&quot;，参数：&quot;+args);&#125; 5.4.7、获取通知的相关信息①获取连接点信息 获取连接点信息可以在通知方法的参数位置设置JoinPoint类型的形参 12345678@Before(&quot;execution(public int com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;)public void beforeMethod(JoinPoint joinPoint)&#123; //获取连接点的签名信息 String methodName = joinPoint.getSignature().getName(); //获取目标方法到的实参信息 String args = Arrays.toString(joinPoint.getArgs()); System.out.println(&quot;Logger--&gt;前置通知，方法名：&quot;+methodName+&quot;，参数：&quot;+args);&#125; ②获取目标方法的返回值 @AfterReturning中的属性returning，用来将通知方法的某个形参，接收目标方法的返回值 12345@AfterReturning(value = &quot;execution(* com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;, returning = &quot;result&quot;)public void afterReturningMethod(JoinPoint joinPoint, Object result)&#123; String methodName = joinPoint.getSignature().getName(); System.out.println(&quot;Logger--&gt;返回通知，方法名：&quot;+methodName+&quot;，结果：&quot;+result);&#125; ③获取目标方法的异常 @AfterThrowing中的属性throwing，用来将通知方法的某个形参，接收目标方法的异常 12345@AfterThrowing(value = &quot;execution(* com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;, throwing = &quot;ex&quot;)public void afterThrowingMethod(JoinPoint joinPoint, Throwable ex)&#123; String methodName = joinPoint.getSignature().getName(); System.out.println(&quot;Logger--&gt;异常通知，方法名：&quot;+methodName+&quot;，异常：&quot;+ex);&#125; 5.4.8、环绕通知123456789101112131415161718@Around(&quot;execution(* com.atguigu.aop.annotation.CalculatorImpl.*(..))&quot;)public Object aroundMethod(ProceedingJoinPoint joinPoint)&#123; String methodName = joinPoint.getSignature().getName(); String args = Arrays.toString(joinPoint.getArgs()); Object result = null; try &#123; System.out.println(&quot;环绕通知--&gt;目标对象方法执行之前&quot;); //目标方法的执行，目标方法的返回值一定要返回给外界调用者 result = joinPoint.proceed(); System.out.println(&quot;环绕通知--&gt;目标对象方法返回值之后&quot;); &#125; catch (Throwable throwable) &#123; throwable.printStackTrace(); System.out.println(&quot;环绕通知--&gt;目标对象方法出现异常时&quot;); &#125; finally &#123; System.out.println(&quot;环绕通知--&gt;目标对象方法执行完毕&quot;); &#125; return result;&#125; 5.4.9、切面的优先级相同目标方法上同时存在多个切面时，切面的优先级控制切面的内外嵌套顺序。 优先级高的切面：外面 优先级低的切面：里面 使用@Order注解可以控制切面的优先级： @Order(较小的数)：优先级高 @Order(较大的数)：优先级低 6、单元测试：JUnit在之前的测试方法中，几乎都能看到以下的两行代码： 12ApplicationContext context = new ClassPathXmlApplicationContext(&quot;xxx.xml&quot;);Xxxx xxx = context.getBean(Xxxx.class); 这两行代码的作用是创建Spring容器，最终获取到对象，但是每次测试都需要重复编写。针对上述问题，我们需要的是程序能自动帮我们创建容器。我们都知道JUnit无法知晓我们是否使用了 Spring 框架，更不用说帮我们创建 Spring 容器了。Spring提供了一个运行器，可以读取配置文件（或注解）来创建容器。我们只需要告诉它配置文件位置就可以了。这样一来，我们通过Spring整合JUnit可以使程序创建spring容器了 6.1、整合JUnit56.1.1、搭建子模块搭建spring-junit模块 6.1.2、引入依赖1234567891011121314151617181920212223242526272829303132333435&lt;dependencies&gt; &lt;!--spring context依赖--&gt; &lt;!--当你引入Spring Context依赖之后，表示将Spring的基础依赖引入了--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;6.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--spring对junit的支持相关依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;6.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--junit5测试--&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt; &lt;version&gt;5.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--log4j2的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;version&gt;2.19.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-slf4j2-impl&lt;/artifactId&gt; &lt;version&gt;2.19.0&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 6.1.3、添加配置文件beans.xml 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;com.atguigu.spring6.bean&quot;/&gt;&lt;/beans&gt; copy日志文件：log4j2.xml 6.1.4、添加java类我们要执行User 1234567891011package com.atguigu.spring6.bean;import org.springframework.stereotype.Component;@Componentpublic class User &#123; public User() &#123; System.out.println(&quot;run user&quot;); &#125;&#125; 6.1.5、测试123456789101112131415161718192021222324import com.atguigu.spring6.bean.User;import org.junit.jupiter.api.Test;import org.junit.jupiter.api.extension.ExtendWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit.jupiter.SpringExtension;import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;//两种方式均可//方式一//@ExtendWith(SpringExtension.class)//@ContextConfiguration(&quot;classpath:beans.xml&quot;)//方式二@SpringJUnitConfig(locations = &quot;classpath:beans.xml&quot;)public class SpringJUnit5Test &#123; @Autowired private User user; @Test public void testUser()&#123; System.out.println(user); &#125;&#125; （不用看）6.2、整合JUnit4JUnit4在公司也会经常用到，在此也学习一下 6.2.1、添加依赖123456&lt;!-- junit测试 --&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt;&lt;/dependency&gt; 6.2.2、测试12345678910111213141516171819import com.atguigu.spring6.bean.User;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&quot;classpath:beans.xml&quot;)public class SpringJUnit4Test &#123; @Autowired private User user; @Test public void testUser()&#123; System.out.println(user); &#125;&#125; 7、事务7.1、JdbcTemplate7.1.1、简介 Spring 框架对 JDBC 进行封装，使用 JdbcTemplate 方便实现对数据库操作 7.1.2、准备工作①搭建子模块 搭建子模块：spring-jdbc-tx ②加入依赖 1234567891011121314151617181920&lt;dependencies&gt; &lt;!--spring jdbc Spring 持久化层支持jar包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;6.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MySQL驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.30&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据源 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.2.15&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; ③创建jdbc.properties 1234jdbc.user=rootjdbc.password=rootjdbc.url=jdbc:mysql://localhost:3306/spring?characterEncoding=utf8&amp;useSSL=falsejdbc.driver=com.mysql.cj.jdbc.Driver ④配置Spring的配置文件 beans.xml 123456789101112131415161718192021222324252627&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 导入外部属性文件 --&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot; /&gt; &lt;!-- 配置数据源 --&gt; &lt;bean id=&quot;druidDataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.user&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置 JdbcTemplate --&gt; &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;!-- 装配数据源 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;druidDataSource&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; ⑤准备数据库与测试表 1234567891011CREATE DATABASE `spring`;use `spring`;CREATE TABLE `t_emp` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(20) DEFAULT NULL COMMENT &#x27;姓名&#x27;, `age` int(11) DEFAULT NULL COMMENT &#x27;年龄&#x27;, `sex` varchar(2) DEFAULT NULL COMMENT &#x27;性别&#x27;, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; 7.1.3、实现CURD①装配 JdbcTemplate创建测试类，整合JUnit，注入JdbcTemplate 12345678910111213package com.atguigu.spring6;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;@SpringJUnitConfig(locations = &quot;classpath:beans.xml&quot;)public class JDBCTemplateTest &#123; @Autowired private JdbcTemplate jdbcTemplate;//注入 &#125; ②测试增删改功能123456789101112131415@Test//测试增删改功能public void testUpdate()&#123; //添加功能\tString sql = &quot;insert into t_emp values(null,?,?,?)&quot;;//预编译方式\tint result = jdbcTemplate.update(sql, &quot;张三&quot;, 23, &quot;男&quot;); //修改功能\t//String sql = &quot;update t_emp set name=? where id=?&quot;; //int result = jdbcTemplate.update(sql, &quot;张三atguigu&quot;, 1); //删除功能\t//String sql = &quot;delete from t_emp where id=?&quot;;\t//int result = jdbcTemplate.update(sql, 1);&#125; ③查询数据返回对象1234567891011121314151617181920public class Emp &#123; private Integer id; private String name; private Integer age; private String sex; //生成get和set方法 //...... @Override public String toString() &#123; return &quot;Emp&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, sex=&#x27;&quot; + sex + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 12345678910111213141516171819202122//查询：返回对象@Testpublic void testSelectObject() &#123; //写法一 jdk8 ResultSet rs // String sql = &quot;select * from t_emp where id=?&quot;;// Emp empResult = jdbcTemplate.queryForObject(sql,// (rs, rowNum) -&gt; &#123;// Emp emp = new Emp();// emp.setId(rs.getInt(&quot;id&quot;));// emp.setName(rs.getString(&quot;name&quot;));// emp.setAge(rs.getInt(&quot;age&quot;));// emp.setSex(rs.getString(&quot;sex&quot;));// return emp;// &#125;, 1);// System.out.println(empResult); //写法二，底层是方法1，这里相当于是简洁写法 String sql = &quot;select * from t_emp where id=?&quot;; Emp emp = jdbcTemplate.queryForObject(sql, new BeanPropertyRowMapper&lt;&gt;(Emp.class),1); System.out.println(emp);&#125; ④查询数据返回list集合用query，调的函数不一样 1234567@Test//查询多条数据为一个list集合public void testSelectList()&#123; String sql = &quot;select * from t_emp&quot;; List&lt;Emp&gt; list = jdbcTemplate.query(sql, new BeanPropertyRowMapper&lt;&gt;(Emp.class)); System.out.println(list);&#125; ⑤查询返回单个的值1234567@Test//查询单行单列的值public void selectCount()&#123; String sql = &quot;select count(id) from t_emp&quot;; Integer count = jdbcTemplate.queryForObject(sql, Integer.class); System.out.println(count);&#125; 7.2、声明式事务概念7.2.1、事务基本概念①什么是事务数据库事务( transaction)是访问并可能操作各种数据项的一个数据库操作序列，这些操作要么全部执行,要么全部不执行，是一个不可分割的工作单位。事务由事务开始与事务结束之间执行的全部数据库操作组成。 ②事务的特性A：原子性(Atomicity) 一个事务(transaction)中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。 C：一致性(Consistency) 事务的一致性指的是在一个事务执行之前和执行之后数据库都必须处于一致性状态。 如果事务成功地完成，那么系统中所有变化将正确地应用，系统处于有效状态。 如果在事务中出现错误，那么系统中的所有变化将自动地回滚，系统返回到原始状态。 I：隔离性(Isolation) 指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。事务查看数据更新时，数据所处的状态要么是另一事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看到中间状态的数据。 D：持久性(Durability) 指的是只要事务成功结束，它对数据库所做的更新就必须保存下来。即使发生系统崩溃，重新启动数据库系统后，数据库还能恢复到事务成功结束时的状态。 7.2.2、编程式事务事务功能的相关操作全部通过自己编写代码来实现：太原始了，不方便 1234567891011121314151617181920212223Connection conn = ...; try &#123; // 开启事务：关闭事务的自动提交 conn.setAutoCommit(false); // 核心操作 // 提交事务 conn.commit(); &#125;catch(Exception e)&#123; // 回滚事务 conn.rollBack(); &#125;finally&#123; // 释放数据库连接 conn.close(); &#125; 编程式的实现方式存在缺陷： 细节没有被屏蔽：具体操作过程中，所有细节都需要程序员自己来完成，比较繁琐。 代码复用性不高：如果没有有效抽取出来，每次实现功能都需要自己编写代码，代码就没有得到复用。 7.2.3、声明式事务既然事务控制的代码有规律可循，代码的结构基本是确定的，所以框架就可以将固定模式的代码抽取出来，进行相关的封装。 封装起来后，我们只需要在配置文件中进行简单的配置即可完成操作。 好处1：提高开发效率 好处2：消除了冗余的代码 好处3：框架会综合考虑相关领域中在实际开发环境下有可能遇到的各种问题，进行了健壮性、性能等各个方面的优化 所以，我们可以总结下面两个概念： 编程式：自己写代码实现功能 声明式：通过配置让框架实现功能 7.3、基于注解的声明式事务7.3.1、准备工作①添加配置 在beans.xml添加配置 12&lt;!--扫描组件--&gt;&lt;context:component-scan base-package=&quot;com.atguigu.spring6&quot;&gt;&lt;/context:component-scan&gt; ②创建表 123456789101112131415CREATE TABLE `t_book` ( `book_id` int(11) NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;, `book_name` varchar(20) DEFAULT NULL COMMENT &#x27;图书名称&#x27;, `price` int(11) DEFAULT NULL COMMENT &#x27;价格&#x27;, `stock` int(10) unsigned DEFAULT NULL COMMENT &#x27;库存（无符号）&#x27;, PRIMARY KEY (`book_id`)) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;insert into `t_book`(`book_id`,`book_name`,`price`,`stock`) values (1,&#x27;斗破苍穹&#x27;,80,100),(2,&#x27;斗罗大陆&#x27;,50,100);CREATE TABLE `t_user` ( `user_id` int(11) NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;, `username` varchar(20) DEFAULT NULL COMMENT &#x27;用户名&#x27;, `balance` int(10) unsigned DEFAULT NULL COMMENT &#x27;余额（无符号）&#x27;, PRIMARY KEY (`user_id`)) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;insert into `t_user`(`user_id`,`username`,`balance`) values (1,&#x27;admin&#x27;,50); ③创建组件 创建BookController： 123456789101112package com.atguigu.spring6.controller;@Controllerpublic class BookController &#123; @Autowired private BookService bookService; public void buyBook(Integer bookId, Integer userId)&#123; bookService.buyBook(bookId, userId); &#125;&#125; 创建接口BookService： 1234package com.atguigu.spring6.service;public interface BookService &#123; void buyBook(Integer bookId, Integer userId);&#125; 创建实现类BookServiceImpl： 1234567891011121314151617package com.atguigu.spring6.service.impl;@Servicepublic class BookServiceImpl implements BookService &#123; @Autowired private BookDao bookDao; @Override public void buyBook(Integer bookId, Integer userId) &#123; //查询图书的价格 Integer price = bookDao.getPriceByBookId(bookId); //更新图书的库存 bookDao.updateStock(bookId); //更新用户的余额 bookDao.updateBalance(userId, price); &#125;&#125; 创建接口BookDao： 12345678package com.atguigu.spring6.dao;public interface BookDao &#123; Integer getPriceByBookId(Integer bookId); void updateStock(Integer bookId); void updateBalance(Integer userId, Integer price);&#125; 创建实现类BookDaoImpl： 12345678910111213141516171819202122232425package com.atguigu.spring6.dao.impl;@Repositorypublic class BookDaoImpl implements BookDao &#123; @Autowired private JdbcTemplate jdbcTemplate; @Override public Integer getPriceByBookId(Integer bookId) &#123; String sql = &quot;select price from t_book where book_id = ?&quot;; return jdbcTemplate.queryForObject(sql, Integer.class, bookId); &#125; @Override public void updateStock(Integer bookId) &#123; String sql = &quot;update t_book set stock = stock - 1 where book_id = ?&quot;; jdbcTemplate.update(sql, bookId); &#125; @Override public void updateBalance(Integer userId, Integer price) &#123; String sql = &quot;update t_user set balance = balance - ? where user_id = ?&quot;; jdbcTemplate.update(sql, price, userId); &#125;&#125; 7.3.2、测试无事务情况①创建测试类 1234567891011121314151617import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;@SpringJUnitConfig(locations = &quot;classpath:beans.xml&quot;)public class TxByAnnotationTest &#123; @Autowired private BookController bookController; @Test public void testBuyBook()&#123; bookController.buyBook(1, 1); &#125;&#125; ②模拟场景 用户购买图书，先查询图书的价格，再更新图书的库存和用户的余额 假设用户id为1的用户，购买id为1的图书 用户余额为50，而图书价格为80 购买图书之后，用户的余额为-30，数据库中余额字段设置了无符号，因此无法将-30插入到余额字段 此时执行sql语句会抛出SQLException ③观察结果 因为没有添加事务，图书的库存更新了，但是用户的余额没有更新 显然这样的结果是错误的，购买图书是一个完整的功能，更新库存和更新余额要么都成功要么都失败 7.3.3、事物配置xml①添加事务配置在spring配置文件中引入tx命名空间 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt; 在Spring的配置文件中添加配置： 12345678910&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;druidDataSource&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 开启事务的注解驱动 通过注解@Transactional所标识的方法或标识的类中所有的方法，都会被事务管理器管理事务--&gt;&lt;!-- transaction-manager属性的默认值是transactionManager，如果事务管理器bean的id正好就是这个默认值，则可以省略这个属性 --&gt;&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot; /&gt; ②添加事务注解因为service层表示业务逻辑层，一个方法表示一个完成的功能，因此处理事务一般在service层处理 在BookServiceImpl的buybook()添加注解@Transactional ③观察结果由于使用了Spring的声明式事务，更新库存和更新余额都没有执行 ⭐7.3.4、@Transactional注解标识的位置@Transactional标识在方法上，则只会影响该方法 @Transactional标识的类上，则会影响类中所有的方法 7.3.5、事务属性：只读（只能查询）①介绍 对一个查询操作来说，如果我们把它设置成只读，就能够明确告诉数据库，这个操作不涉及写操作。这样数据库就能够针对查询操作来进行优化。 ②使用方式 12345678910@Transactional(readOnly = true)public void buyBook(Integer bookId, Integer userId) &#123; //查询图书的价格 Integer price = bookDao.getPriceByBookId(bookId); //更新图书的库存 bookDao.updateStock(bookId); //更新用户的余额 bookDao.updateBalance(userId, price); //System.out.println(1/0);&#125; ③注意 对增删改操作设置只读会抛出下面异常： Caused by: java.sql.SQLException: Connection is read-only. Queries leading to data modification are not allowed 7.3.6、事务属性：超时（操作时间超过限制就回滚）①介绍 事务在执行过程中，有可能因为遇到某些问题，导致程序卡住，从而长时间占用数据库资源。而长时间占用资源，大概率是因为程序运行出现了问题（可能是Java程序或MySQL数据库或网络连接等等）。此时这个很可能出问题的程序应该被回滚，撤销它已做的操作，事务结束，把资源让出来，让其他正常程序可以执行。 概括来说就是一句话：超时回滚，释放资源。 ②使用方式 12345678910111213141516//超时时间单位秒@Transactional(timeout = 3)public void buyBook(Integer bookId, Integer userId) &#123; try &#123; TimeUnit.SECONDS.sleep(5); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //查询图书的价格 Integer price = bookDao.getPriceByBookId(bookId); //更新图书的库存 bookDao.updateStock(bookId); //更新用户的余额 bookDao.updateBalance(userId, price); //System.out.println(1/0);&#125; ③观察结果 执行过程中抛出异常： org.springframework.transaction.TransactionTimedOutException: Transaction timed out: deadline was Fri Jun 04 16:25:39 CST 2022 7.3.7、事务属性：回滚策略①介绍 声明式事务默认只针对运行时异常回滚，编译时异常不回滚。 可以通过@Transactional中相关属性设置回滚策略 rollbackFor属性：需要设置一个Class类型的对象 rollbackForClassName属性：需要设置一个字符串类型的全类名 上面两个设置哪些异常可以回滚 下面两个设置哪些异常不能回滚 noRollbackFor属性：需要设置一个Class类型的对象 rollbackFor属性：需要设置一个字符串类型的全类名 ②使用方式 1234567891011@Transactional(noRollbackFor = ArithmeticException.class)//@Transactional(noRollbackForClassName = &quot;java.lang.ArithmeticException&quot;)public void buyBook(Integer bookId, Integer userId) &#123; //查询图书的价格 Integer price = bookDao.getPriceByBookId(bookId); //更新图书的库存 bookDao.updateStock(bookId); //更新用户的余额 bookDao.updateBalance(userId, price); System.out.println(1/0);&#125; ③观察结果 虽然购买图书功能中出现了数学运算异常（ArithmeticException），但是我们设置的回滚策略是，当出现ArithmeticException不发生回滚，因此购买图书的操作正常执行 7.3.8、事务属性：隔离级别①介绍 数据库系统必须具有隔离并发运行各个事务的能力，使它们不会相互影响，避免各种并发问题。一个事务与其他事务隔离的程度称为隔离级别。SQL标准中规定了多种事务隔离级别，不同隔离级别对应不同的干扰程度，隔离级别越高，数据一致性就越好，但并发性越弱。 隔离级别一共有四种： 读未提交：READ UNCOMMITTED 允许Transaction01读取Transaction02未提交的修改。 读已提交：READ COMMITTED、 要求Transaction01只能读取Transaction02已提交的修改。 可重复读：REPEATABLE READ 确保Transaction01可以多次从一个字段中读取到相同的值，即Transaction01执行期间禁止其它事务对这个字段进行更新。 串行化：SERIALIZABLE 确保Transaction01可以多次从一个表中读取到相同的行，在Transaction01执行期间，禁止其它事务对这个表进行添加、更新、删除操作。可以避免任何并发问题，但性能十分低下。 各个隔离级别解决并发问题的能力见下表： 隔离级别 脏读 不可重复读 幻读 READ UNCOMMITTED 有 有 有 READ COMMITTED 无 有 有 REPEATABLE READ 无 无 有 SERIALIZABLE 无 无 无 各种数据库产品对事务隔离级别的支持程度： 隔离级别 Oracle MySQL READ UNCOMMITTED × √ READ COMMITTED √(默认) √ REPEATABLE READ × √(默认) SERIALIZABLE √ √ ②使用方式 12345@Transactional(isolation = Isolation.DEFAULT)//使用数据库默认的隔离级别@Transactional(isolation = Isolation.READ_UNCOMMITTED)//读未提交@Transactional(isolation = Isolation.READ_COMMITTED)//读已提交@Transactional(isolation = Isolation.REPEATABLE_READ)//可重复读@Transactional(isolation = Isolation.SERIALIZABLE)//串行化 7.3.9、事务属性：传播行为（没看懂）①介绍 什么是事务的传播行为？ 在service类中有a()方法和b()方法，a()方法上有事务，b()方法上也有事务，当a()方法执行过程中调用了b()方法，事务是如何传递的？合并到一个事务里？还是开启一个新的事务？这就是事务传播行为。 一共有七种传播行为： REQUIRED：支持当前事务，如果不存在就新建一个(默认)【没有就新建，有就加入】 SUPPORTS：支持当前事务，如果当前没有事务，就以非事务方式执行【有就加入，没有就不管了】 MANDATORY：必须运行在一个事务中，如果当前没有事务正在发生，将抛出一个异常【有就加入，没有就抛异常】 REQUIRES_NEW：开启一个新的事务，如果一个事务已经存在，则将这个存在的事务挂起【不管有没有，直接开启一个新事务，开启的新事务和之前的事务不存在嵌套关系，之前事务被挂起】 NOT_SUPPORTED：以非事务方式运行，如果有事务存在，挂起当前事务【不支持事务，存在就挂起】 NEVER：以非事务方式运行，如果有事务存在，抛出异常【不支持事务，存在就抛异常】 NESTED：如果当前正有一个事务在进行中，则该方法应当运行在一个嵌套式事务中。被嵌套的事务可以独立于外层事务进行提交或回滚。如果外层事务不存在，行为就像REQUIRED一样。【有事务的话，就在这个事务里再嵌套一个完全独立的事务，嵌套的事务可以独立的提交和回滚。没有事务就和REQUIRED一样。】 ②测试 创建接口CheckoutService： 12345package com.atguigu.spring6.service;public interface CheckoutService &#123; void checkout(Integer[] bookIds, Integer userId);&#125; 创建实现类CheckoutServiceImpl： 1234567891011121314151617package com.atguigu.spring6.service.impl;@Servicepublic class CheckoutServiceImpl implements CheckoutService &#123; @Autowired private BookService bookService; @Override @Transactional //一次购买多本图书 public void checkout(Integer[] bookIds, Integer userId) &#123; for (Integer bookId : bookIds) &#123; bookService.buyBook(bookId, userId); &#125; &#125;&#125; 在BookController中添加方法： 123456@Autowiredprivate CheckoutService checkoutService;public void checkout(Integer[] bookIds, Integer userId)&#123; checkoutService.checkout(bookIds, userId);&#125; 在数据库中将用户的余额修改为100元 ③观察结果 可以通过@Transactional中的propagation属性设置事务传播行为 修改BookServiceImpl中buyBook()上，注解@Transactional的propagation属性 @Transactional(propagation = Propagation.REQUIRED)，默认情况，表示如果当前线程上有已经开启的事务可用，那么就在这个事务中运行。经过观察，购买图书的方法buyBook()在checkout()中被调用，checkout()上有事务注解，因此在此事务中执行。所购买的两本图书的价格为80和50，而用户的余额为100，因此在购买第二本图书时余额不足失败，导致整个checkout()回滚，即只要有一本书买不了，就都买不了 @Transactional(propagation = Propagation.REQUIRES_NEW)，表示不管当前线程上是否有已经开启的事务，都要开启新事务。同样的场景，每次购买图书都是在buyBook()的事务中执行，因此第一本图书购买成功，事务结束，第二本图书购买失败，只在第二次的buyBook()中回滚，购买第一本图书不受影响，即能买几本就买几本。 7.3.10、全注解配置事务①添加配置类 12345678910111213141516171819202122232425262728293031323334353637383940package com.atguigu.spring6.config;import com.alibaba.druid.pool.DruidDataSource;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.datasource.DataSourceTransactionManager;import org.springframework.transaction.annotation.EnableTransactionManagement;import javax.sql.DataSource;@Configuration@ComponentScan(&quot;com.atguigu.spring6&quot;)@EnableTransactionManagementpublic class SpringConfig &#123; @Bean public DataSource getDataSource()&#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setDriverClassName(&quot;com.mysql.cj.jdbc.Driver&quot;); dataSource.setUrl(&quot;jdbc:mysql://localhost:3306/spring?characterEncoding=utf8&amp;useSSL=false&quot;); dataSource.setUsername(&quot;root&quot;); dataSource.setPassword(&quot;root&quot;); return dataSource; &#125; @Bean(name = &quot;jdbcTemplate&quot;) public JdbcTemplate getJdbcTemplate(DataSource dataSource)&#123; JdbcTemplate jdbcTemplate = new JdbcTemplate(); jdbcTemplate.setDataSource(dataSource); return jdbcTemplate; &#125; @Bean public DataSourceTransactionManager getDataSourceTransactionManager(DataSource dataSource)&#123; DataSourceTransactionManager dataSourceTransactionManager = new DataSourceTransactionManager(); dataSourceTransactionManager.setDataSource(dataSource); return dataSourceTransactionManager; &#125;&#125; ②测试 1234567891011121314151617import com.atguigu.spring6.config.SpringConfig;import com.atguigu.spring6.controller.BookController;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;public class TxByAllAnnotationTest &#123; @Test public void testTxAllAnnotation()&#123; ApplicationContext applicationContext = new AnnotationConfigApplicationContext(SpringConfig.class); BookController accountService = applicationContext.getBean(&quot;bookController&quot;, BookController.class); accountService.buyBook(1, 1); &#125;&#125; 8、资源操作：Resources8.1、Spring Resources概述 Java的标准java.net.URL类和各种URL前缀的标准处理程序无法满足所有对low-level资源的访问，比如：没有标准化的 URL 实现可用于访问需要从类路径或相对于 ServletContext 获取的资源。并且缺少某些Spring所需要的功能，例如检测某资源是否存在等。而Spring的Resource声明了访问low-level资源的能力。 8.2、Resource接口Spring 的 Resource 接口位于 org.springframework.core.io 中。 旨在成为一个更强大的接口，用于抽象对低级资源的访问。以下显示了Resource接口定义的方法 12345678910111213141516171819202122232425262728public interface Resource extends InputStreamSource &#123; boolean exists(); boolean isReadable(); boolean isOpen(); boolean isFile();//是否是文件 URL getURL() throws IOException; URI getURI() throws IOException; File getFile() throws IOException; ReadableByteChannel readableChannel() throws IOException; long contentLength() throws IOException; long lastModified() throws IOException; Resource createRelative(String relativePath) throws IOException; String getFilename(); String getDescription();&#125; Resource接口继承了InputStreamSource接口，提供了很多InputStreamSource所没有的方法。InputStreamSource接口，只有一个方法： 12345public interface InputStreamSource &#123; InputStream getInputStream() throws IOException;&#125; 其中一些重要的方法： getInputStream(): 找到并打开资源，返回一个InputStream以从资源中读取。预计每次调用都会返回一个新的InputStream()，调用者有责任关闭每个流exists(): 返回一个布尔值，表明某个资源是否以物理形式存在isOpen: 返回一个布尔值，指示此资源是否具有开放流的句柄。如果为true，InputStream就不能够多次读取，只能够读取一次并且及时关闭以避免内存泄漏。对于所有常规资源实现，返回false，但是InputStreamResource除外。getDescription(): 返回资源的描述，用来输出错误的日志。这通常是完全限定的文件名或资源的实际URL。 其他方法： isReadable(): 表明资源的目录读取是否通过getInputStream()进行读取。isFile(): 表明这个资源是否代表了一个文件系统的文件。getURL(): 返回一个URL句柄，如果资源不能够被解析为URL，将抛出IOExceptiongetURI(): 返回一个资源的URI句柄getFile(): 返回某个文件，如果资源不能够被解析称为绝对路径，将会抛出FileNotFoundExceptionlastModified(): 资源最后一次修改的时间戳createRelative(): 创建此资源的相关资源getFilename(): 资源的文件名是什么 例如：最后一部分的文件名 myfile.txt 8.3、Resource的实现类Resource 接口是 Spring 资源访问策略的抽象，它本身并不提供任何资源访问实现，具体的资源访问由该接口的实现类完成——每个实现类代表一种资源访问策略。Resource一般包括这些实现类：UrlResource、ClassPathResource、FileSystemResource、ServletContextResource、InputStreamResource、ByteArrayResource 8.3.1、UrlResource访问网络资源Resource的一个实现类，用来访问网络资源，它支持URL的绝对路径。 http:———该前缀用于访问基于HTTP协议的网络资源。 ftp:———该前缀用于访问基于FTP协议的网络资源 file: ———该前缀用于从文件系统中读取资源 实验：访问基于HTTP协议的网络资源 创建一个maven子模块spring6-resources，配置Spring依赖（参考前面） 12345678910111213141516171819202122232425262728package com.atguigu.spring6.resources;import org.springframework.core.io.UrlResource;public class UrlResourceDemo &#123; public static void loadAndReadUrlResource(String path)&#123; // 创建一个 Resource 对象 UrlResource url = null; try &#123; url = new UrlResource(path); // 获取资源名 System.out.println(url.getFilename()); System.out.println(url.getURI()); // 获取资源描述 System.out.println(url.getDescription()); //获取资源内容 System.out.println(url.getInputStream().read()); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; public static void main(String[] args) &#123; //访问网络资源 loadAndReadUrlResource(&quot;http://www.baidu.com&quot;); &#125;&#125; 实验二：在项目根路径下创建文件，从文件系统中读取资源 方法不变，修改调用传递路径 1234567public static void main(String[] args) &#123; //1 访问网络资源\t//loadAndReadUrlResource(&quot;http://www.atguigu.com&quot;); //2 访问文件系统资源 loadAndReadUrlResource(&quot;file:atguigu.txt&quot;);&#125; 8.3.2、ClassPathResource 访问类路径下资源ClassPathResource 用来访问类加载路径下的资源，相对于其他的 Resource 实现类，其主要优势是方便访问类加载路径里的资源，尤其对于 Web 应用，ClassPathResource 可自动搜索位于 classes 下的资源文件，无须使用绝对路径访问。 实验：在类路径下创建文件atguigu.txt，使用ClassPathResource 访问 1234567891011121314151617181920212223242526package com.atguigu.spring6.resources;import org.springframework.core.io.ClassPathResource;import java.io.InputStream;public class ClassPathResourceDemo &#123; public static void loadAndReadUrlResource(String path) throws Exception&#123; // 创建一个 Resource 对象 ClassPathResource resource = new ClassPathResource(path); // 获取文件名 System.out.println(&quot;resource.getFileName = &quot; + resource.getFilename()); // 获取文件描述 System.out.println(&quot;resource.getDescription = &quot;+ resource.getDescription()); //获取文件内容 InputStream in = resource.getInputStream(); byte[] b = new byte[1024]; while(in.read(b)!=-1) &#123; System.out.println(new String(b)); &#125; &#125; public static void main(String[] args) throws Exception &#123; loadAndReadUrlResource(&quot;atguigu.txt&quot;); &#125;&#125; ClassPathResource实例可使用ClassPathResource构造器显式地创建，但更多的时候它都是隐式地创建的。当执行Spring的某个方法时，该方法接受一个代表资源路径的字符串参数，当Spring识别该字符串参数中包含classpath:前缀后，系统会自动创建ClassPathResource对象。 8.3.3、FileSystemResource 访问文件系统资源Spring 提供的 FileSystemResource 类用于访问文件系统资源，使用 FileSystemResource 来访问文件系统资源并没有太大的优势，因为 Java 提供的 File 类也可用于访问文件系统资源。 实验：使用FileSystemResource 访问文件系统资源 1234567891011121314151617181920212223242526272829package com.atguigu.spring6.resources;import org.springframework.core.io.FileSystemResource;import java.io.InputStream;public class FileSystemResourceDemo &#123; public static void loadAndReadUrlResource(String path) throws Exception&#123; //相对路径 FileSystemResource resource = new FileSystemResource(&quot;atguigu.txt&quot;); //绝对路径 //FileSystemResource resource = new FileSystemResource(&quot;C:\\\\atguigu.txt&quot;); // 获取文件名 System.out.println(&quot;resource.getFileName = &quot; + resource.getFilename()); // 获取文件描述 System.out.println(&quot;resource.getDescription = &quot;+ resource.getDescription()); //获取文件内容 InputStream in = resource.getInputStream(); byte[] b = new byte[1024]; while(in.read(b)!=-1) &#123; System.out.println(new String(b)); &#125; &#125; public static void main(String[] args) throws Exception &#123; loadAndReadUrlResource(&quot;atguigu.txt&quot;); &#125;&#125; FileSystemResource实例可使用FileSystemResource构造器显示地创建，但更多的时候它都是隐式创建。执行Spring的某个方法时，该方法接受一个代表资源路径的字符串参数，当Spring识别该字符串参数中包含file:前缀后，系统将会自动创建FileSystemResource对象。 8.3.4、ServletContextResource这是ServletContext资源的Resource实现，它解释相关Web应用程序根目录中的相对路径。它始终支持流(stream)访问和URL访问，但只有在扩展Web应用程序存档且资源实际位于文件系统上时才允许java.io.File访问。无论它是在文件系统上扩展还是直接从JAR或其他地方（如数据库）访问，实际上都依赖于Servlet容器。 8.3.5、InputStreamResourceInputStreamResource 是给定的输入流(InputStream)的Resource实现。它的使用场景在没有特定的资源实现的时候使用(感觉和@Component 的适用场景很相似)。与其他Resource实现相比，这是已打开资源的描述符。 因此，它的isOpen()方法返回true。如果需要将资源描述符保留在某处或者需要多次读取流，请不要使用它。 8.3.6、ByteArrayResource字节数组的Resource实现类。通过给定的数组创建了一个ByteArrayInputStream。它对于从任何给定的字节数组加载内容非常有用，而无需求助于单次使用的InputStreamResource。 8.4、Resource类图上述Resource实现类与Resource顶级接口之间的关系可以用下面的UML关系模型来表示 8.5、ResourceLoader 接口8.5.1、ResourceLoader 概述Spring 提供如下两个标志性接口： （1）ResourceLoader ： 该接口实现类的实例可以获得一个Resource实例。 （2） ResourceLoaderAware ： 该接口实现类的实例将获得一个ResourceLoader的引用。 在ResourceLoader接口里有如下方法： （1）Resource getResource（String location） ： 该接口仅有这个方法，用于返回一个Resource实例。ApplicationContext实现类都实现ResourceLoader接口，因此ApplicationContext可直接获取Resource实例。 8.5.2、使用演示实验一：ClassPathXmlApplicationContext获取Resource实例 1234567891011121314151617package com.atguigu.spring6.resouceloader;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.core.io.Resource;public class Demo1 &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext();// 通过ApplicationContext访问资源// ApplicationContext实例获取Resource实例时，// 默认采用与ApplicationContext相同的资源访问策略 Resource res = ctx.getResource(&quot;atguigu.txt&quot;); System.out.println(res.getFilename()); &#125;&#125; 实验二：FileSystemApplicationContext获取Resource实例 1234567891011121314package com.atguigu.spring6.resouceloader;import org.springframework.context.ApplicationContext;import org.springframework.context.support.FileSystemXmlApplicationContext;import org.springframework.core.io.Resource;public class Demo2 &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new FileSystemXmlApplicationContext(); Resource res = ctx.getResource(&quot;atguigu.txt&quot;); System.out.println(res.getFilename()); &#125;&#125; 8.5.3、ResourceLoader 总结Spring将采用和ApplicationContext相同的策略来访问资源。也就是说，如果ApplicationContext是FileSystemXmlApplicationContext，res就是FileSystemResource实例；如果ApplicationContext是ClassPathXmlApplicationContext，res就是ClassPathResource实例 当Spring应用需要进行资源访问时，实际上并不需要直接使用Resource实现类，而是调用ResourceLoader实例的getResource()方法来获得资源，ReosurceLoader将会负责选择Reosurce实现类，也就是确定具体的资源访问策略，从而将应用程序和具体的资源访问策略分离开来 另外，使用ApplicationContext访问资源时，可通过不同前缀指定强制使用指定的ClassPathResource、FileSystemResource等实现类 123Resource res = ctx.getResource(&quot;calsspath:bean.xml&quot;);Resrouce res = ctx.getResource(&quot;file:bean.xml&quot;);Resource res = ctx.getResource(&quot;http://localhost:8080/beans.xml&quot;); 8.6、ResourceLoaderAware 接口ResourceLoaderAware接口实现类的实例将获得一个ResourceLoader的引用，ResourceLoaderAware接口也提供了一个setResourceLoader()方法，该方法将由Spring容器负责调用，Spring容器会将一个ResourceLoader对象作为该方法的参数传入。 如果把实现ResourceLoaderAware接口的Bean类部署在Spring容器中，Spring容器会将自身当成ResourceLoader作为setResourceLoader()方法的参数传入。由于ApplicationContext的实现类都实现了ResourceLoader接口，Spring容器自身完全可作为ResorceLoader使用。 实验：演示ResourceLoaderAware使用 第一步 创建类，实现ResourceLoaderAware接口 12345678910111213141516171819202122package com.atguigu.spring6.resouceloader;import org.springframework.context.ResourceLoaderAware;import org.springframework.core.io.ResourceLoader;public class TestBean implements ResourceLoaderAware &#123; private ResourceLoader resourceLoader; //实现ResourceLoaderAware接口必须实现的方法\t//如果把该Bean部署在Spring容器中，该方法将会有Spring容器负责调用。\t//SPring容器调用该方法时，Spring会将自身作为参数传给该方法。 public void setResourceLoader(ResourceLoader resourceLoader) &#123; this.resourceLoader = resourceLoader; &#125; //返回ResourceLoader对象的应用 public ResourceLoader getResourceLoader()&#123; return this.resourceLoader; &#125;&#125; 第二步 创建bean.xml文件，配置TestBean 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;testBean&quot; class=&quot;com.atguigu.spring6.resouceloader.TestBean&quot;&gt;&lt;/bean&gt;&lt;/beans&gt; 第三步 测试 12345678910111213141516171819202122package com.atguigu.spring6.resouceloader;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.core.io.Resource;import org.springframework.core.io.ResourceLoader;public class Demo3 &#123; public static void main(String[] args) &#123; //Spring容器会将一个ResourceLoader对象作为该方法的参数传入 ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;); TestBean testBean = ctx.getBean(&quot;testBean&quot;,TestBean.class); //获取ResourceLoader对象 ResourceLoader resourceLoader = testBean.getResourceLoader(); System.out.println(&quot;Spring容器将自身注入到ResourceLoaderAware Bean 中 ？ ：&quot; + (resourceLoader == ctx)); //加载其他资源 Resource resource = resourceLoader.getResource(&quot;atguigu.txt&quot;); System.out.println(resource.getFilename()); System.out.println(resource.getDescription()); &#125;&#125; 8.7、使用Resource 作为属性前面介绍了 Spring 提供的资源访问策略，但这些依赖访问策略要么需要使用 Resource 实现类，要么需要使用 ApplicationContext 来获取资源。实际上，当应用程序中的 Bean 实例需要访问资源时，Spring 有更好的解决方法：直接利用依赖注入。从这个意义上来看，Spring 框架不仅充分利用了策略模式来简化资源访问，而且还将策略模式和 IoC 进行充分地结合，最大程度地简化了 Spring 资源访问。 归纳起来，如果 Bean 实例需要访问资源，有如下两种解决方案： 代码中获取 Resource 实例。 使用依赖注入。 对于第一种方式，当程序获取 Resource 实例时，总需要提供 Resource 所在的位置，不管通过 FileSystemResource 创建实例，还是通过 ClassPathResource 创建实例，或者通过 ApplicationContext 的 getResource() 方法获取实例，都需要提供资源位置。这意味着：资源所在的物理位置将被耦合到代码中，如果资源位置发生改变，则必须改写程序。因此，通常建议采用第二种方法，让 Spring 为 Bean 实例依赖注入资源。 实验：让Spring为Bean实例依赖注入资源 第一步 创建依赖注入类，定义属性和方法 1234567891011121314151617181920package com.atguigu.spring6.resouceloader;import org.springframework.core.io.Resource;public class ResourceBean &#123; private Resource res; public void setRes(Resource res) &#123; this.res = res; &#125; public Resource getRes() &#123; return res; &#125; public void parse()&#123; System.out.println(res.getFilename()); System.out.println(res.getDescription()); &#125;&#125; 第二步 创建spring配置文件，配置依赖注入 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;resourceBean&quot; class=&quot;com.atguigu.spring6.resouceloader.ResourceBean&quot; &gt; &lt;!-- 可以使用file:、http:、ftp:等前缀强制Spring采用对应的资源访问策略 --&gt; &lt;!-- 如果不采用任何前缀，则Spring将采用与该ApplicationContext相同的资源访问策略来访问资源 --&gt; &lt;property name=&quot;res&quot; value=&quot;classpath:atguigu.txt&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 第三步 测试 1234567891011121314package com.atguigu.spring6.resouceloader;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Demo4 &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;); ResourceBean resourceBean = ctx.getBean(&quot;resourceBean&quot;,ResourceBean.class); resourceBean.parse(); &#125;&#125; 8.8、应用程序上下文和资源路径8.8.1、概述不管以怎样的方式创建ApplicationContext实例，都需要为ApplicationContext指定配置文件，Spring允许使用一份或多分XML配置文件。当程序创建ApplicationContext实例时，通常也是以Resource的方式来访问配置文件的，所以ApplicationContext完全支持ClassPathResource、FileSystemResource、ServletContextResource等资源访问方式。 ApplicationContext确定资源访问策略通常有两种方法： （1）使用ApplicationContext实现类指定访问策略。 （2）使用前缀指定访问策略。 8.8.2、ApplicationContext实现类指定访问策略创建ApplicationContext对象时，通常可以使用如下实现类： （1） ClassPathXMLApplicationContext : 对应使用ClassPathResource进行资源访问。 （2）FileSystemXmlApplicationContext ： 对应使用FileSystemResource进行资源访问。 （3）XmlWebApplicationContext ： 对应使用ServletContextResource进行资源访问。 当使用ApplicationContext的不同实现类时，就意味着Spring使用响应的资源访问策略。 效果前面已经演示 8.8.3、使用前缀指定访问策略实验一：classpath前缀使用 12345678910111213141516171819202122package com.atguigu.spring6.context;import org.springframework.context.ApplicationContext;import org.springframework.context.support.FileSystemXmlApplicationContext;import org.springframework.core.io.Resource;public class Demo1 &#123; public static void main(String[] args) &#123; /* * 通过搜索文件系统路径下的xml文件创建ApplicationContext， * 但通过指定classpath:前缀强制搜索类加载路径 * classpath:bean.xml * */ ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;classpath:bean.xml&quot;); System.out.println(ctx); Resource resource = ctx.getResource(&quot;atguigu.txt&quot;); System.out.println(resource.getFilename()); System.out.println(resource.getDescription()); &#125;&#125; 实验二：classpath通配符使用 classpath :前缀提供了加载多个XML配置文件的能力，当使用classpath:前缀来指定XML配置文件时，系统将搜索类加载路径，找到所有与文件名匹配的文件，分别加载文件中的配置定义，最后合并成一个ApplicationContext。 12ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;classpath*:bean.xml&quot;);System.out.println(ctx); 当使用classpath * :前缀时，Spring将会搜索类加载路径下所有满足该规则的配置文件。 如果不是采用classpath * :前缀，而是改为使用classpath:前缀，Spring则只加载第一个符合条件的XML文件 注意 ： classpath : 前缀仅对ApplicationContext有效。实际情况是，创建ApplicationContext时，分别访问多个配置文件(通过ClassLoader的getResource方法实现)。因此，classpath :前缀不可用于Resource。 使用三：通配符其他使用 一次性加载多个配置文件的方式：指定配置文件时使用通配符 1ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;classpath:bean*.xml&quot;); Spring允许将classpath*:前缀和通配符结合使用： 1ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;classpath*:bean*.xml&quot;); AOT 提前编译1、JIT just in time 动态编译（实时） 在程序运行时，动态生成代码，启动比较满。 程序运行过程中，把字节码转换到硬盘上直接运行机器码，部署到环境过程 2、AOT ahead of time 可以把源代码直接转换机器码，启动快，内存占用低，运行时不能优化，程序安装过长 在程序运行之前，就把字节码转换到机器码 简单来讲，Java 虚拟机加载已经预编译成二进制库，可以直接执行。不必等待及时编译器的预热，减少 Java 应用给人带来“第一次运行慢” 的不良体验。 在程序运行前编译，可以避免在运行时的编译性能消耗和内存消耗可以在程序运行初期就达到最高性能，程序启动速度快运行产物只有机器码，打包体积小 缺点，由于是静态提前编译，不能根据硬件情况或程序运行情况择优选择机器指令序列，理论峰值性能不如JIT没有动态能力，同一份产物不能跨平台运行 GraalvmSpring6 支持的 AOT 技术，这个 GraalVM 就是底层的支持，Spring 也对 GraalVM 本机映像提供了一流的支持。GraalVM 是一种高性能 JDK，旨在加速用 Java 和其他 JVM 语言编写的应用程序的执行，同时还为 JavaScript、Python 和许多其他流行语言提供运行时。 GraalVM 提供两种运行 Java 应用程序的方法：在 HotSpot JVM 上使用 Graal 即时 (JIT) 编译器或作为提前 (AOT) 编译的本机可执行文件。 GraalVM 的多语言能力使得在单个应用程序中混合多种编程语言成为可能，同时消除了外语调用成本。GraalVM 向 HotSpot Java 虚拟机添加了一个用 Java 编写的高级即时 (JIT) 优化编译器。 GraalVM 具有以下特性： （1）一种高级优化编译器，它生成更快、更精简的代码，需要更少的计算资源 （2）AOT 本机图像编译提前将 Java 应用程序编译为本机二进制文件，立即启动，无需预热即可实现最高性能 （3）Polyglot 编程在单个应用程序中利用流行语言的最佳功能和库，无需额外开销 （4）高级工具在 Java 和多种语言中调试、监视、分析和优化资源消耗 总的来说对云原生的要求不算高短期内可以继续使用 2.7.X 的版本和 JDK8，不过 Spring 官方已经对 Spring6 进行了正式版发布。"},{"title":"Java基础复习","path":"/2023/04/25/java/","content":"IDEA常用快捷1、自动导包、自动删包 1 2.if快速生成 1234567//flag.ifif(flag)&#123; &#125;//flag.elseif(!flag)&#123;&#125; 3、循环 1234//forifor(int i=0;i&lt;10;i++)&#123;&#125;//flag.while 4、变量 1new String().var 基础面试 Java基础复习已看尚硅谷Java零基础全套视频教程(宋红康2023版，java入门自学必备) P64 P79 P80 P81 P107 p108 java面试选择题以下关于HashMap的说法正确的是()A HashMap类的key可以重复 B HashMap类的key可以为null C HashMap类的value不可以为null值 D HashMap类的value可以包含null值，并且只能有1个 key和value可以为null，但key只能存在一个null，位于组数的0位置：因为hash(key)方法，当key=null ，返回0。存储对象时，存储为key的对象需要重写equals()方法。 为使对象可以保存到磁盘上或在网络上传输，需要首先经过如下什么操作( )将对象转换成字节数组序列化 char类型占( )个字节 2在java中，char占用2个字节。Java中，只要是字符，不管是数字还是英文还是汉字，都占两个字节。原因：Java编译器默认使用Unicode编码，因此2字节可以表示所有字符。 byte是 Java基本类型中的一个 是 1个字节 hashCode()在Java中，我们所讲的本地接口书写程序或者本地方法接口指的是JNI，JNI是Java Native Interface的缩写 java标识符需要遵循哪些规则标识符必须以字母(包括汉字)、下划线、美元符($)开头 识符的其他部分可以是字母、下划线、数字、美元符的任意组合 Java标识符大小写敏感，且无长度限制 java跨平台原理Java 源代码经过编译，生成字节码文件，交由 Java 虚拟机来执行，不同得系统有不同得JVM,借助JVM 实现跨平台。 以下哪些关键字与Java面向对象的概念相关A override B throws C extends D implements ACD override是重写，也可以算吧，是实现接口 Java IO体系中，通常情况下以下哪个类可用来读取文件且产生的系统调用可能是最少的A、RandomAccessFileB、FileInputStreamC、BufferedReaderD、InputStreamReader C 对于方法sleep()和wait()对于sleep()方法，我们首先要知道该方法是属于Thread类中的。而wait()方法，则是属于Object类中的。 这两个方法来自不同的类分别是Thread和Object，最主要是sleep方法没有释放锁，而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法(锁代码块和方法锁)。wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方,任何时候被任何线程使用(使用范围) sleep必须捕获异常，而wait notify和notifyAll不需要捕获异常。 Java中的基本数据类型官方解析：基本数据类型有：byte，short，int，long，char，boolean，float，double String不算基础数据类型 string字符串new string()、+和substring得到的字符串不会在字符串常量池中，而是存储在堆中。 注意：使用加号时字面量+字面量的结果还是存在常量池。 123String c = &quot;ab&quot;;String d = &quot;a&quot;+&quot;b&quot;;System.out.println(c==d);//true 但是一旦有变量，就会存在堆中， 12345String a = &quot;a&quot;;String b = &quot;b&quot;;String c = &quot;ab&quot;;String d = a+b;System.out.println(c==d);//false “xxxxx”字符串字面量的东西才能放到字符串常量池里。 但是我们可以new string().intern手动放到常量池里面。 多线程线程创建方式1、继承Thread类，java是单继承，这种实现方法不太好 2、实现Runnable，无返回值 3、实现Callable，可以拿到返回值 4、线程池，节省线程创建和销毁的开销 底层都是Runnable的实现方式。 线程池有哪些状态1、running 表示线程池正常运行，既能接受新任务，也会正常处理队列中的任务 2、shutdown 当调用线程池的shutdown方法时，线程池就进入shutdown状态，表示线程池处于正在关闭状态，此状态下线程池不会接受新任务，但是会继续把队列中的任务处理完 3、stop 既不会接收新任务，也不会处理队列中的任务，并且正在运行的线程也会被中断。 4、tidying 如果所有任务都终止了，有效线程数为0，线程池进入该状态后会调用terminated（） 5、terminated 完全结束 线程池的核心线程数应该如何设置？CPU密集型的服务，线程数等于CPU核心数。 IO密集型，（工作时间+休息时间）*CPU核心数/工作时间。目的是为了充分使用时间，比如一个人送快递，工作8小时，休息4小时，那么车就有4小时是空闲的，那么需要另外一个人（cpu）来利用。 最大线程数（非核心线程数=最大线程数-核心线程数） 拒绝策略 当核心线程满了，阻塞队列也满了，非核心线程也满了，就需要执行拒绝策略。 根据业务来走 1、直接抛异常 2、让询问的线程自己去做这个任务（会对询问的线程有影响） 3、将阻塞队列排最前的直接扔了 4、不执行，不反馈，不抛异常，啥也不做{} Sychronized 和ReentrantLock有什么不同？java内存划分将内存区域划分成5个部分：程序计数器、虚拟机栈、本地方法栈、堆、方法区。 与目前数组相关的内存结构： 虚拟机栈：用于存放方法中声明的局部变量 堆：用于存放数组的实体（即数组的所有元素） 一维数组 放int数据类型的情况 放对象数组的情况 二维数组 多态以父类声明的子类对象，只能使用父类中的方法。 方法的重载参数列表不同：1、参数个数不同 2、参数类型不同 3、参数顺序不同 与形参名、修饰符、返回值类型无关。 可变形参1(参数类型 ... 参数名) 可变形参需要放最后。 注意：这种是不能共存的 java 访问权限 一个类必须有且仅有一个公共类 （子包不能访问父包的default) 单例设计模式 饿汉式：立即加载；优点：写法简单，使用更快，更方便，已在内存中加载 缺点：内存占用时间较长 懒汉式：延迟加载优点：节省内存空间 缺点：线程不安全 代码块 静态代码块：随着类的加载而执行，类的加载只会执行一次，进而静态代码块的执行，也只会执行一次；静态代码块的执行会先于非静态代码块的执行。 非静态代码块：随着对象的创建而执行。 接口与抽象类包含抽象方法的类，必须是抽象类。抽象类不能创建对象 一个类只能继承一个抽象类，而一个类却可以实现多个接口。 接口的数据成员（public static final,全局常量）都是静态的且必须初始化，数据成员必须是静态常量。 接口的方法可以是抽象方法、私有方法、静态方法、默认方法。 反射动态性 lambda表达式-&gt; lambda操作符 -&gt; 左边lambda形参列表，对应着要重写的接口中的抽象方法的形参列表。 -&gt; 的右边lambda体，对应着接口要实现类要重写方法的方法体。 使用lambda表达式： 线程池1.降低资源消耗:通过池化技术重复利用已创建的线程，降低线程创建和销毁造成的损耗。 2.提高响应速度:任务到达时，无需等待线程创建即可立即执行（如果有空闲的线程）。3.提高线程的可管理性:线程是稀缺资源，如果无限制创建，个仅会泪R系沉贡源，贮云公为线程的不合理分布导致资源调度失衡，降低系统的稳定性。使用线程池可以进行统一的分配、调优和监控。4.提供更多更强大的功能:线程池具备可拓展性，允许开发人员向其中增加更多的功能。比如延时定时线程池ScheduledThreadPoolExecutor，就允许任务延期执行或定期执行。"},{"title":"hexo常用操作","path":"/2023/04/21/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. hexo常用操作部署先在本地预览1hexo server # hexo s，本地服务器预览预览后觉得没问题了，就可以部署了12hexo generate\t# hexo g，构建项目静态文件，输出到/publichexo deploy # hexo d，部署 生成新md1hexo new &#x27;文章名&#x27; # hexo n &#x27;文章&#x27;，生成新的md文件"}]